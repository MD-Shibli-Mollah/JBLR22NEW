*-----------------------------------------------------------------------------
* <Rating>7632</Rating>
*-----------------------------------------------------------------------------
* Version 3 13/06/01  GLOBUS Release No. 200511 03/10/05
*************************************************************************
    SUBROUTINE BATCH.JOB.CONTROL(JOB.INFO)
*************************************************************************
*
* This routine is used to control the process where multiple sessions
* may be used to run this job.
*
* From I_BATCH.FILES common:
* The SESSION.NO is used to determine the portion of the list to process
* and KEYS.PROCESSED is the total number of contracts which were processed.
*-----------------------------------------------------------------------------
* Modifications
*
* 20/04/00 - GB0001096
*            Don't allow the batch routine to corrupt the key that's passed
*
* 12/06/01 - GB0101735
*            In Multi-threaded EOD, record locks for LD
*            and LMM.SCHEDULES.PAST are not released
*            properly. As a result teh EOD gets stuck.
*            This can be fixed by using a RELEASE command after finishing
*            a transaction
*
* 22/01/02 - EN10000402
*            A PRE and POST routine are added to the EOD. They are checked
*            to see if they exist using CHECK.ROUTINE.EXIST.
*
* 09/11/02 - EN_10001339
*            Enable re-start of job after crash and allow .SELECT routines
*            to manage more than one select list - ie replace exisiting
*            control routines with a generic mechanism. Remove pre and post routine support
*            changes to core batch routine for commitment control
*
* 30/10/02 - BG_100002614
*            Spelling mistake while init the variable LISTS.PROCESSED.
*
* 18/11/02 - BG_100002722
*            Enable re-start of job after crash and allow .SELECT routines
*            to manage more than one select list - ie replace exisiting
*            control routines with a generic mechanism. Also update job times
*            here rather than S.BATCH.RUN.
*
* 22/11/02 - BG_100002841
*            Remove CRT for CONTROL.LIST
*
* 1/12/02 -  BG_100002910
*            BATCH.JOB.CONTROL CHANGES
*            CRT IS CHANGED BY CALLING A NEW ROUTINE OCOMO
*
*            Use OCOMO for outputting to the como file and
*            change processing when list reduces to near zero
*            to avoid repetitive selects.
*
* 26/12/02 - BG_100003080(BG_100002910)
*            Correction for new batch changes
*
* 03/01/03 - BG_100003119
*            The varaible RECORD.ROUTINE is assigned to JOB.ROUTINE, if
*            STANDARD.JOB.is set to false.
*
* 08/01/03 - BG_100003135
*            Correction for BG_100003119
*            Execution of COMMAND from PGM.FILE is commented.
*
* 21/02/03 - BG_100003549
*            Batch abruptly stops if USER.FLAGGED.HALT
*
* 10/03/03 - BG_100003752
*            Update BATCH.STATUS record of the current job
*            with "processed" when job is completed
*
* 19/03/03 - BG_100003814
*            Get the current CONTROL.LIST from BATCH.STATUS of the job
*            before processing records in list file.
*
* 23/03/03 - BG_100003837
*            Use of list file FXXX.JOB.LIST.Y where XXX is the company
*            mnemonic and Y the session number.
*
* 07/04/03 - CI_10008062
*            Changes done to support generic list file processing.
*
* 27/05/03 - EN_10001831
*            This is part of the Core Batch changes for Multi-Book Processing
*            Read the contract record and pick up the company code.
*
* 11/06/03 - EN_10001864
*            Populate JOB.TIMES with progress. Throughput figure will now
*            show an incremental count of the keys (contracts not lists)
*            processed while the job is running and it will show the fastest
*            throughput of a SINGLEthread once the job is complete. The
*            former is used to monitor progress while running and the
*            latter is used to compare previous runs - if it is increasing
*            then it indicates a problem (file sizing??:).
*            Also periodically check the next service for this agent and
*            go back to S.JOB.RUN if it changes.
*
* 08/07/03 - BG_100004694
*            Improve the company ID checking for KEY list ID in multi book
*            Takes whole ot part of key to read the record containing the company code
*
* 25/07/03 - BG_100004873
*            Changes done to solve the problem of repgens in jBase
*            due to Transaction Mgmt. Repgens write into a work
*            file, select it and print. Since the work file writes happen
*            into cache - the select does not work on it.
*            So we check if the JOB.NAME is EB.EOD.REPORT.PRINT then
*            do not call EB.TRANS for that job.
*
* 27/08/03 - BG_100005037
*            To get the correct SPF record before calling the main routine
*
* 21/10/03 - BG_100005444
*            Two changes are done under this Change.Document:
*            1. If not of Activation.File always use generic list file.
*            2. Clear the .LIST file before using it.
*
* 09/12/03 - BG_100005787
*            The following changes are done under this CD:
*            1. Re-introduction of changes done under BG_100003814 and
*               CI_10008062.
*            2. We go and select the .LIST file only if the .select
*               routine has selected records and written into the .List file.
*            3. Previously the key(FLAG.ID) to F.BATCH.STATUS was MNEMONIC/JOB.NAME.
*               Now the FLAG.ID is of the format PROCESS.NAME-JOB.NAME
*            4. Changes done to handle CONTRACT$ID of the format "00".
*            5. The process of clearing the .LIST file is altered.
*
* 10/12/03 - BG_100005796
*            The procedure of clearing the .LIST file is reverted to
*            BG_100005444
*
* 08/03/04 - CI_10017904
*            The following two changes have been done:
*            1. The .LIST file is no longer cleared.
*            2. If record locked in the .LIST file and if number of keys less than
*               number of sessions then pause before doing the select again
*
* 08/04/04 - BG_100006511
*            For record routines, do not call EB.TRANS if the PGM.TYPE
*            for the routine has additional info set as ".NTX"
*
* 07/05/04 - CI_10019620
*            When same job.name occurs more than once in a batch record we have
*            problem in getting its position in the batch record. Also we have
*            problem in maintaning the the uniqueness of the FLAG.ID. Changes done
*            to handle this. Now the FLAG.ID is of the format:
*            FLAG.ID = <PROCESS.NAME>-<JOB.NAME>-<POS OF THE JOB IN THE PROCESS>
*            Ref :HD0401950
*
* 10/05/04 - BG_100006900
*            1. Process individual contracts in the list in a transaction unit
*            rather than the entire list record. This allows a more effecient build
*            of the list file (less records) and better control of lock contentions
*            when processing multiple business transactions in a single database
*            transaction.
*            2. Reduce OCOMO output of ControlList - first 50chars
*            3. Move EB.READ.SPF - so that it's invoked only once for a job
*            4. Create an initial list of JobList keys automatically - to avoid selecting
*            the job list file first. When there a N number of misses - then go and
*            select the file.
*            5. Record the number of active agents in the job times record
*            6. Update JOB.PROGRESS (in common) to tell SERVICE.HEARTBEAT where we are
*            1=Processing Contracts
*            2=Selecting Contracts
*            3=Managing Control List
*            4=Selecting list file
*            5=Managing Batch record (in S.JOB.RUN)
*            6=Waiting on list record
*            7=Processing Single threaded
*
* 21/09/04 - CI_10023328
*            1. When checking for the agent status, if it is not running go to PROGRAM.END
*            instead of PROGRAM.ABORT.
*            Ref: HD0480197
*            2. Calculate the OFFSET correctly.
*            3. If KEYS.PROCESSED = -1, then change it to zero before updating JOB.TIMES.
*            4. Lock and delete the F.LOCKING record which holds the name of the .LIST file.
*
* 22/09/04 - BG_100007283
*            Changes done to handle CONTRACT$ID of the format "00"
*
* 23/09/04 - BG_100007289
*            Force heartbeat to record a singlethread job - this will tell the
*            tSM NOT to kill the agent if the heartbeat goes beyond the deathwatch
*            Change the END.GAME to check when the BATCH.STATUS record when the
*            number of keys in the list file reduces to 100. Also check this when
*            the number of keys in MY portion reduces to this figure - in case a thread
*            empties the list file from GT 100 to zero in one go.
*
* 11/10/04 - BG_100007441
*            The Session which allocates the .LIST should not use the run ahead mechanism.
*
* 21/10/04 - CI_10024128
*            Dont Run Ahead if an agent is trying to process the job again
*            in the cycle of run ahead when there is nothing to run ahead
*            Also Introduction of new threshold - JOB.THRESHOLD which will
*            dictate the starting of read to BATCH.STATUS for completion
*            END.GAME.THRESHOLD is now number of sessions  which will
*            be used to run ahead.
*
* 21/12/04 - CI_10025864
*            1. Don't set END.GAME for every extracted portion. Set it only when we
*               are really at the end of the list and no more IDs to process.
*            2. Don't start to sleep as soon as we find a record locked in .LIST file
*               and END.GAME set. Sleep only when there is no more ID left in the .LIST file and can't RUN.AHEAD
*            3. Increase RECORD.MISS by 1, if a ID is locked by another session and moving to next ID
*            4. When unable to lock and read a .LIST file record and waking up from sleep and
*               sucessfully able to lock now, check for the job.status again because the ID might
*               belong to next job.
*
* 05/01/05 -  BG_100007865
*             1. The session which runs the .SELECT routine alone can use MAX.LIST.ID to get the
*             no.of.records in the .LIST file. Other sessions should select the .LIST file to
*             get the no.of.records.
*             2. Incase the record.routine passes an argument back to BJC, we substitue the
*             original Key.Id in LIST.RECORD with the passed argument. Otherwise remove the Key.Id
*             from LIST.RECORD as usual.
*
* 17/02/05 - BG_100008122
*            Assign FN.LIST.NAME with the name of the .LIST file.
*
* 25/07/05 - CI_10030546
*            Activation file processing , Allow SEAT logging at record key level
*
*
* 29/11/05 - EN_10002713
*            1. Distribute the List Records when you get down to the end and there
*               are more than one batch keys in the list record
*            2. Allocate the list file based on availability. Maintain a locking reference
*               keyed on the list file name. Availalble job list will be allocated to a job
*               than based on the current session number
*            3. Tidy up the CHECK.STATUS paragraph.
*
* 12/12/05 - GLOBUS_CI_10037219
*            Changes to multi-book processing to allow for mt.key.file containing a suffix
*
* 30/01/06 - CI_10038508
*            Do not spilt out empty ID.LIST via OCOMO
*            Ref:HD0517254
*
* 01/02/06 - CI_10038624
*            JBASE does not recognize characters like
*            '-','.' etc properly, hence failing in CHECK.COMPANY
*            para, in loading the book in MB environment.
*
* 02/02/06 - BG_100010166
*            Bug fixes for the enhancement - EN_10002713
*
* 15/02/06 - CI_10038991
*            .NOL option to be provided to enable non reporting  of locks
*
* 14/06/06 - CI_10041844
*            SEAT integration in DEV
*
* 25/07/06 - CI_10042787
*            Introduction of new common variable SEAT.SCRIPT to hold the Seat
*            Script details.
*
* 17/08/06 - BG_100011810
*            Changes made for Seat
*
* 25/08/06 - CI_10043592
*            EB.EOD.REPORT.PRINT shall b construed as single threaded and the ports need not
*            be logged off. This ensures that big reports dont get logged off and DEATH.WATCH
*            need not be set too high just because of reporting problems
*
* 12/09/06 - CI_10044016
*            Multi-threaded Job runs only in one session.
*
* 06/12/06 - EN_10003145
*            If DW is installed then go and call DW.PROCESS.TXN to check for DW extracts
*            Ref: SAR-2006-09-19-0007
*
* 19/12/06 - CI_10046224
*            Changes have been made not to update the Seat Results ID with **CONTRACT.ID
*            while updating Seat Results for online jobs.
*
* 02/02/07 - BG_100012866
*            Seat changes done to cater for Single thread jobs furing COB.
*
* 27/03/07 - CI_10048043
*            The Batch job IC.CAPITALISATION takes more
*            than a hour to complete the job.
*
* 22/05/07 - CI_10049235
*            Invoke TEC to store number of transactions processed. Do this during the 'progress'
*            phase when updating job times and at the end of the job passing the difference
*            between Completed & Processed - so that the final update of the TEC matches the actual
*            number of contracts processed. Also clear SYSTEM(1036), the lock collision counter, prior
*            to invoking the record routine - as we don't want to record lock collisions from BJC
*            because its design is based on lock management.
*
* 31/05/07 - BG_100014021
*            Call to ALLOCATE.UNIQUE.TIME is moved to DW.PROCESS.TXN
*
* 01/06/07 - BG_100014041
*            Just dummy flag to enable SEAT for single threaded job
*
* 05/06/07 - BG_100014073
*            Removing the checks to LOCK.STATUS before and after calling SELECT routine
*
* 14/06/07 - CI_10049791
*            job name and process name should be updated even for services.
*
* 25/06/07 - CI_10049975(TTS0753504)/BG_100015170
*            Initialize LIST.OWNER to 0 in the INITIALIASE sec
*
* 24/07/07 - BG_100014498
*            Call to T.SEAT with FINISH option depends on the flag NO.CALL.TO.T.SEAT.FINI.BJC
*
* 10/08/07 - BG_100014805
*            The flag NO.CALL.TO.T.SEAT.FINI.BJC is made as NULL if it is ZERO.
*
* 10/09/07 - CI_10051276
*            AGENT.STATUS field displays RUNNING value in TSA.STATUS even though the agent has
*            been stopped by modifying the SERVICE.CONTROL field to STOP in TSA.SERVICE.
*            HD Ref: HD0714895
*
* 19/09/07 - CI_10051450
*            While running the RUN.CONVERSION service, if any file routine
*            takes more than the time specified in the DEATH.WATCH , tsm logs off the agent.
*
* 11/10/07 - BG_100015396
*            Write the actual no of records to be processed and no of key count processed in
*            CONTROL.LIST<1,4> and CONTROL.LIST<1,5> resp
*
* 18/10/07 - BG_100015483
*            In the CHECK.JOB.STATUS para, just check whether CURRENT.CONTROL.LIST<1,1> is same
*            as CONTROL.LIST<1,1> and not for the entire value.
*
* 31/10/07 - BG_100015423
*            Changes made to stop creating a duplicate SEAT.RESULTS id in Online.
*
* 09/11/07 - CI_10052409
*            tSA COMO-output file remains incomplete without "Agent stopped" and
*            "COMO COMPLETED" messages.
*            HD REF:HD0719734
*
* 21/11/07 - BG_100015760
*            The changes done to avoid T.SEAT call, during script uploading.
*
* 28/11/07 - BG_100016477
*            Changes made to populate the variable SEAT.SCRIPT only when SEAT is used.
*
* 13/03/08 - BG_10017676
*            PROGRESS mispelled as UPDATE.PROGESS.BATCH.STATUS
*
* 14/03/08 - CI_10054170
*            When a multithread job is run as a service with SERVICE.CONTROL set to
*            AUTO,select routine is executed in multiple sessions.
*
* 20/03/08 - CI_10054277
*            TSA.STATUS not changed to "STOPPED" when a NEXT.SERVICE is allocated to
*            a RUNNING agent.
*
* 24/03/08 - CI_10054325
*            Uninitialised variable FN.LIST.FILE.
*
* 24/03/08 - BG_100017812
*            Code added to capture the start and end time of a SERVICE for TV.
*
* 29/04/08 - CI_10055058
*            Added SelectAhead mechanism.
*            Added new field to JobTimes - SelectStart & Highest Response
*
* 21/05/08 - CI_10055510/ BG_100018659
*                 In the paragraph ADVANCE.CONTROL.LIST we should ensure that we also purge
*                 the locking records while setting the batch status as PROCESSED.So that both
*                 processing occur in the same txn boundary.
*                 Ref: HD0723406
*
* 07/06/08 - BG_100019073
*            Bug Fix for SelectAhead changes.
*            Highest response not updated.
*
* 22/07/08 - EN_10003752
*            If .KEY specified then use the key of the ACTIVATION file and not the record content.
*
* 29/07/08 - CI_10056973
*            Cannot run service which has an  activation file associated with it.
*
* 11/09/08 - EN_10003814
*            BATCH.JOB.CONTROL to now update new fields like TXN.MANAGEMENT,BULK.NUMBER
*            READ.WRITE.CACHE etc. added in JOB.TIMES and a new file JOB.TIMES.HISTORY as well.
*            Checks whether the record routine has the Verification mechanism and if so, update
*            a field REC.VER in PGM.FILE.If the WRITE.CACHE is enabled, then the records are
*            retrieved from the cache and written into the disk as we do it in JOUYRNAL.UPDATE.
*
* 19/09/2008 - CI_10057849(Ref: HD0823457)
*                       Don't enable the run ahead option for Online Services
*
* 09/10/2008 - BG_100020327
*              Use the cache only if '.NUC' is set in the PGM.FILE pf the JOB.
*
* 24/10/08 -  CI_10057692
*             Save and restore the variable for Default printer
*             CSS.REF:HD0818388
*
* 24/10/08 - EN_10003892
*            Write Cache needs to be implemented for the entire bulk boundary.
*            Cache need to be cleared at the end of Bulk Boundary
*            REF:SAR-2008-08-29-0004
*
* 05/10/08 - BG_100020679
*            Write Cache Updates need to be done at end of Bulk Boundary
*            REF:SAR-2008-08-29-0004
*
* 29/12/08 - GLOBUS_CI_10059735
*            FLAG.ID locking record is deleted only when its content matches the List Name.
*            HD Ref: HD0830414
*
* 03/02/01 - BG_100021918
*            Job START.TIME is not updated in JOB.TIMES file.
*            REF:TTS0905109
*
* 04/02/09 - BG_100021935
*            All the cob jobs by default would use WRITE.CACHE.The cob jobs would not use
*            WRITE.CACHE only if .NUC(not use cache) is set in the PGM file of the job.
*            Reverting the fix done in the cd BG_100020327.
*
* 04/02/09 - BG_100021934
*            Parameterise updating JOB.TIMES.HISTORY on SEAT
*            TTS Ref : TTS0905476
*
* 05/03/09 - BG_100022484
*            Review time to be taken from TSA.SERVICE if not defined then
*            take it from TSA.PARAMETER.
*
* 24/04/09 - BG_100023370
*            TOTAL.WRITE field in JOB.TIMES and JOB.TIMES.HISTORY is updated.
*
* 16/07/09 - BG_100024534
*            Single threaded jobs not to use WRITE.CACHE as the cache size is exceeded.
*
* 19/08/09 - CI_10065463
*            ".NTX" jobs not to use WRITE.CACHE as the transaction management is not started
*            here in BJC.
*
* 24/08/09 - CI_10065571
*            When an agent is waiting for the last record of the job to be processed,
*            COMO is filled up unnecessarily with the message "Available list IDs exhausted"
*            REF : HD0929075
*
* 08/01/10 - CI_10068628
*           While retrieving new job list file, agent waits until the first agent
*           releases the lock of Locking File.
*           Minimized the locks made on LOCKING file to improve the COB performance.
*           REF : HD1000009
*
* 21/10/2010 - CI_10071771
*            1) Activation file based services need not wait for the lock on the last id and
*            can continue with the next set of select as there is no dependency to switch
*            to the next job.
*            2) The activation file based service would sleep for the review time when all the
*            ids are being locked by other agents to process.
*
* 01/11/10 - CI_10071885(REF:HD1045011)
*            SLEEP.TIME is reduced on two occasions ,to trigger the distribution process
*            1)When list file has more than 100 records
*            2)Or when Next control list exits
*
* 14/12/10 - EN_10004644
*            Put CBE generation hooks into T24
*
* 24/02/11 - CI_10072712(Defect:154581)
*            Global release has to be performed after processing every record routine.
*
* 25/02/11 - CI_10072723 (Defect 132726)
*            COB crash when same JOB.LIST that was used by multi threaded job was reused
*            by single threaded job.
*
* 1/03/11 - CI_10072748
*            If the keys processed is zero and no more items in the control list just update
*            the job times with 'END' part as well during processing KEYS.
*
* 15/03/11 - BG_100027072
*            JOB.PENDING events generated for jobs that don't run
*
* 24/03/11 - CI_10072917 ( Defect 169698 )
*            While running the ARC.STATEMENT service,if processing time is more than the time specified in the DEATH.WATCH
*            tsm logs off the agent.
*
* 05/04/11 - CI_10073003 (Task : 185893) / REF (DEFECT : 182126)
*            Initialise das common variable "dasMode" before starting the Job
*
* 14/07/11 - BG_100027246 / Task - 239112
*            R09 Back Patch
*
* 11/11/11 - CI_10074438
*            Locking contentions found in the TSA.SERVICE
*
*-----------------------------------------------------------------------------------------
    $INSERT I_COMMON
    $INSERT I_EQUATE
    $INSERT I_BATCH.FILES
    $INSERT I_SEAT.COMMON     ;*CI_10041844 S/E
    $INSERT I_TSA.COMMON      ;* EN_10001864 S/E
    $INSERT I_SHARED.SERVICE.COMMON
    $INSERT I_F.COMPANY
    $INSERT I_F.SPF
    $INSERT I_F.JOB.TIMES
    $INSERT I_F.TSA.STATUS    ;* EN_10001864 S/E
    $INSERT I_F.TSA.PARAMETER ;* EN_10001864 S/E
    $INSERT I_F.PGM.FILE
    $INSERT I_F.VERSION
    $INSERT I_F.DATES         ;* CI_10042787S/E
    $INSERT I_DW.COMMON
    $INSERT I_TV.COMMON       ;* Inserted to get the value of "tvMode" and store the start and end time of a service.
    $INSERT I_IO.EQUATE       ;* Inserted to use the cache variables
    $INSERT I_RC.COMMON
    $INSERT I_F.TSA.SERVICE
    $INSERT I_DAS.COMMON
    $INSERT I_TV.TRANS.COMMON

*-----------------------------------------------------------------------------
*
    GOSUB INITIALISE
    BEGIN CASE
    CASE ACTIVATION.FILE      ;* Permanent agent driven from activation file
        GOSUB PROCESS.ACTIVATION        ;* Scan the activation file
    CASE SELECT.AHEAD         ;* We're trying to prepare the job list ahead of schedule
        READ CONTROL.LIST FROM F.BATCH.STATUS,FLAG.ID ELSE  ;* And it's not been prepared yet
            GOSUB PROCESS.SELECT        ;* Build list file
        END
    CASE OTHERWISE
        GOSUB PROCESS.SELECT  ;* Build list file
    END CASE

    RETURN
*-----------------------------------------------------------------------------
PROCESS.SELECT:

* Build the list file and process until it's empty


    LOOP
        JOB.PROGRESS = 3      ;* In processing control
        CALL SERVICE.HEARTBEAT          ;* Tell em we're still alive
        MAX.LIST.ID = ''      ;* Will hold the number of IDs in the list file
LOCK.CONTROL.LIST:
        READU CONTROL.LIST FROM F.BATCH.STATUS, FLAG.ID LOCKED        ;* Get hold of the control list
            IF SELECT.AHEAD THEN        ;* Another agent is already performing the SelectAhead
                GOTO PROGRAM.ABORT      ;* Get out of here immediately
            END
            SLEEP 2 ;* Wait a couple of seconds
            CALL SERVICE.HEARTBEAT      ;* We need to keep the tSM informed - otherwise we'll get killed
            GOSUB CHECK.SERVICE         ;*See if we still need to continue with this job
            GOTO LOCK.CONTROL.LIST
        END ELSE    ;* In case we are restarting - wait for lock!!!
            CONTROL.LIST = "" ;* First time through for this job
        END
    UNTIL CONTROL.LIST = PROCESSED      ;* Until everything has been done ; * BG_100003752 S/E
        GOSUB CHK.STILL.HOLD.LIST.FILE  ;* check whether we still hold the list file
        IF CONTROL.LIST = "" THEN       ;* First time through
            GOSUB START.JOB   ;* Init job times
        END
* GET.LIST.FROM.POOL is moved here to make the lock happen only once in LOCKING file.
* All other agents get the list name from LOCKING file just by reading it without doing lock
        GOSUB GET.LIST.FROM.POOL        ;* Get a list file from the pool
        IF CONTROL.LIST<1,2> # PROCESSING THEN    ;* ie List not built yet
            JOB.PROGRESS = 2  ;* Selecting contracts
            LAST.CONTACT.TIME = -99     ;*Forces heartbeat
            CALL SERVICE.HEARTBEAT      ;* We're still standing
            GOSUB BUILD.LIST  ;* Call the select routine to build the list
        END ELSE
            WRITE CONTROL.LIST ON F.BATCH.STATUS, FLAG.ID   ;* Write cause we locked it - no need for Trans
        END
        IF SELECT.AHEAD THEN  ;* The list is built - we can't do anymore
            RETURN  ;* This will go straight back to SJR
        END
        CALL OCOMO("Using list file ":FN.LIST.NAME)         ;* List has been built for us
        CALL OCOMO("Control list ":CONTROL.LIST[1,50])      ;* BJC s/e
        JOB.START.TIME = TIME()         ;* If we're the first agent to log our progress then this will be the start time
        IF CONTROL.LIST<1,2> = PROCESSING THEN    ;* This means we're ready to process contracts
            JOB.PROGRESS = 1  ;* Processing contracts
            CALL SERVICE.HEARTBEAT
            GOSUB PROCESS.LIST          ;* Select the list file and do the work
        END         ;* BG_100005787 e
        JOB.PROGRESS = 3      ;* Back in processing control
        CALL SERVICE.HEARTBEAT
        GOSUB ADVANCE.CONTROL ;* Go to the next item in the control list (if it's there)
    REPEAT

    IF CONTROL.LIST = PROCESSED THEN    ;* We're finished
        RELEASE F.BATCH.STATUS, FLAG.ID ;* Because we locked it at the top of the loop
* GOSUB RELEASE.LIST.FILE         ;* need not be called at the end as allocation is done only after getting the lock and the status is not processed
    END   ;* BG_100003752 Ends

    IF NOT(JOB.TIMES.END) THEN          ;* job times has not been ended yet
        CALL EB.TRANS('START',RMSG)
        JOB.OPERATION = 'END ': TIME()  ;* End of job time
        GOSUB UPDATE.JOB.TIMES
        CALL EB.TRANS('END',RMSG)
    END

    RETURN
*-----------------------------------------------------------------------------
START.JOB:
* This thread has started the job. Update job times....

    CALL OCOMO("Starting job")          ;* BG_100005787 S/E
    CALL EB.TRANS('START',RMSG)
    JOB.OPERATION = 'START ':STIME      ;* Create new job times value for this job
    GOSUB UPDATE.JOB.TIMES    ;* Do it
    CALL EB.TRANS('END',RMSG)

    RETURN
*-----------------------------------------------------------------------------
BUILD.LIST:
* Call the select routine and build the list file

    CALL EB.TRANS('START',RMSG)

    KEYS.PROCESSED = -1       ;* Populated by BATCH.BUILD.LIST - initialise to -1 in case the select routine doesn't call BBL
    MAX.LIST.ID = ''          ;* Will hold the number of IDs in the list file
    START.TIME = TIME()       ;* So we can calculate the time taken to do the select

    BEGIN CASE
    CASE STANDARD.JOB         ;* Standard multi-thread jobs have list routines
        CALL OCOMO('Calling..':SELECT.ROUTINE)
        dasMode = dasReturnResults      ;* DAS should return the results in default
        CALL @SELECT.ROUTINE  ;* Select the records to process and updates CONTROL.LIST if we need to call this more than once
        MAX.LIST.ID = KEYS.PROCESSED<2> ;* Number of IDs in the list file
        KEYS.PROCESSED = KEYS.PROCESSED<1>        ;* Number of contracts to process
        CALL OCOMO('Control list.. ':CONTROL.LIST[1,50])    ;* Just the first 50 chars
    CASE OTHERWISE  ;* Non MT job
        WRITE 'SingleThread' ON F.LIST.NAME, '1'  ;* Just one id on the list file ensures single thread activity only
        KEYS.PROCESSED = 1    ;* As it's single thread we can only record 1 key processed in job times
        MAX.LIST.ID = KEYS.PROCESSED    ;* Number of IDs in the list file
        SELECT.STATEMENT='SingleThread' ;* to indicate single threaded routine in JOB.TIMES
    END CASE

* save the control list value to be updated in JOB.TIMES, since if the current control list
* multivalue is the last one and if its selection returns zero record,we set the CONTROL.LIST
* to 'processed'.
    SAVE.CONTROL.LIST =CONTROL.LIST

    IF KEYS.PROCESSED NE 0 THEN         ;* Returned from BATCH.BUILD.LIST - number of contracts to process
        CONTROL.LIST<1,2> = PROCESSING  ;* Signals that we've finished the building of the list
        CONTROL.LIST<1,3> = MAX.LIST.ID ;* Store so the other threads can see it
        CONTROL.LIST<1,4> = KEYS.PROCESSED        ;* store Number of IDs in the list file
    END ELSE
        IF CONTROL.LIST<2> = '' THEN    ;* Nothing left in the control list
            CONTROL.LIST = PROCESSED    ;* So signal we've finished to all threads END
        END ELSE    ;* BG_100005787 ends
            CONTROL.LIST<1,2> = EMPTYLIST         ;*Empty list update it as others can get hold and do a sel. again
        END
    END

    END.TIME = TIME()         ;* To calculate the time the select took
    IF END.TIME LT START.TIME THEN      ;* Flipped over midnight
        SELECT.TIME = END.TIME + (24*3600) - START.TIME     ;* 24hours of seconds
    END ELSE
        SELECT.TIME = END.TIME - START.TIME       ;* How long did the select take
    END

    WRITE CONTROL.LIST ON F.BATCH.STATUS, FLAG.ID ;* Start the threads
    JOB.OPERATION = 'KEYS ':KEYS.PROCESSED        ;* Update job times with number of keys to process and the time of the select
    GOSUB UPDATE.JOB.TIMES    ;* Do it
* Update Temenos Enterprise Console with JOB.SELECT event
    GOSUB UPDATE.TEC.JOB.SELECT

    CALL EB.TRANS('END',RMSG)

    CALL SERVICE.HEARTBEAT    ;* Tell em we're still alive ; * EN_10001864 s/e

    RETURN
*-----------------------------------------------------------------------------
ADVANCE.CONTROL:
* The list is finished - see if there's anything left in control list - if so
* then put it to the top of the list and begin again. If not then set it to
* processed to finish off.

    CALL EB.TRANS('START',RMSG)

    READU NEW.CONTROL.LIST FROM F.BATCH.STATUS, FLAG.ID LOCKED
        CALL EB.TRANS("END","")         ;*CI_10044016 S/E
        RETURN      ;*Someone has already done it or doing it now
    END THEN        ;* Ensure we've got control
        IF NEW.CONTROL.LIST = CONTROL.LIST THEN   ;* This is the first thread to get hold of the record after completing the list
            DEL NEW.CONTROL.LIST<1>     ;* Pop from stack
        END
    END
    IF NEW.CONTROL.LIST = '' THEN       ;* We're finished
        NEW.CONTROL.LIST = PROCESSED    ;* Signal this is the end
        READ R.LIST.FILE.NAME FROM F.LOCKING,FLAG.ID THEN   ;* If found
            GOSUB RELEASE.LIST.FILE     ;* Allow the list file to be used by another job
        END
    END
    WRITE NEW.CONTROL.LIST ON F.BATCH.STATUS, FLAG.ID       ;* And store - in case we need to restart

    IF BATCH.COMPANY NE ID.COMPANY THEN
        CALL LOAD.COMPANY(BATCH.COMPANY)          ;*In case it had changed in record routine
    END

    CALL EB.TRANS('END',RMSG) ;* Hence we've done this one and now onto the next (if there is a next)

    RETURN
*-----------------------------------------------------------------------------
PROCESS.ACTIVATION:
* The 'job' is driven from an activation file (ie put something in the file and it will process it)
* These job's never really end - they stop and start controlled by the tSM - when the service changes it
* leaves via program.abort

    MAX.LIST.ID = ''          ;* This will force a selection rather than building a list from 1 to MAX.LIST.ID
    LOOP
        GOSUB PROCESS.LIST    ;* Process records on the list file
        GOSUB CHECK.SERVICE   ;* See if we need to shut down
        SLEEP SERVICE.REVIEW.TIME       ;* List file empty sleep and then try again
        CALL SERVICE.HEARTBEAT          ;* Tell the tSM we're ok
    REPEAT

    RETURN
*-----------------------------------------------------------------------------
PROCESS.LIST:
* Loop through selecting the list file and processing the contracts

    SEL.CMD = 'SELECT ' : FN.LIST.NAME :' SAMPLE ':LIST.SAMPLE        ;* Make sure we don't end up with a huge list

    FULL.LIST = 'initialise'  ;* This will contain all the keys in the list - initialise means build it first time round
    RECORD.MISS = 0 ;* Count of the number of locks hit or list records missing
    MAX.MISS = 20   ;* Default will be reset to 5% of the number of keys to process
    EOL = 0         ;* Flag to indicate end of the list
    NO.RECORDS.PROCESSED.COUNT = 0      ;* No of time records has not been processed in this lot

    LOOP UNTIL EOL = 1        ;* Until there's nothing left in the list file
        ID.LIST = ''          ;* This holds just the list for this agent
        CALL SERVICE.HEARTBEAT          ;* Tell em we're still alive
        IF FULL.LIST = '' OR FULL.LIST = 'initialise' OR RECORD.MISS GE MAX.MISS THEN     ;* Either we've exhausted this sample or the agents are clashing
            IF SYSTEM(11) THEN          ;* Active select list
                CLEARSELECT   ;* Make sure there's no active select list when calling the record routine!
            END
            JOB.PROGRESS = 4  ;* Selecting list file
            CALL SERVICE.HEARTBEAT
            GOSUB GET.FULL.LIST         ;* Return with a full list of keys to process
            IF FULL.LIST = '' THEN      ;* No more selected
                EOL = 1       ;* Ok we're done
            END
            RECORD.MISS = 0   ;* Reset ready for next loop
        END
        IF FULL.LIST THEN     ;* Something in the list file
            GOSUB EXTRACT.PORTION       ;* Extract my portion of the list to work on
            GOSUB CHECK.JOB.STATUS      ;* Make sure another thread hasn't finished the job
            IF NOT(EOL) THEN  ;* We're still ok to process - another thread hasn't finished the list
                JOB.PROGRESS = 3        ;* Processing contracts
                CALL SERVICE.HEARTBEAT
                GOSUB PROCESS.PORTION   ;* Process each list key in my portion

                IF ACTIVATION.FILE THEN ;* For activation file service
                    IF NO.RECORDS.PROCESSED THEN  ;* no records has been processed and its an activation file
                        NO.RECORDS.PROCESSED.COUNT += 1     ;* increment the no records processed count
                        IF NO.RECORDS.PROCESSED.COUNT = 2 THEN        ;* if two consecutive runs has processed no records
                            EOL = 1     ;* end the list and sleep for the review time
                        END
                    END ELSE  ;* reset it as we need to sleep for the review time only if there are two consecutive times records not processed by the agent
                        NO.RECORDS.PROCESSED.COUNT = 0      ;* reset it as there are records processed.
                    END
                END

            END
        END
    REPEAT
*
    GOSUB GLOBAL.RELEASE      ;* Make sure there are no locks left lying around from the record routines

    RETURN
*-----------------------------------------------------------------------------
GET.FULL.LIST:
* The first time through we can build a list of keys internally as the ID to
* the list file is now wholly numeric. Hence, get the total number of keys - which
* is stored in the CONTROL.LIST<1,3> (from BATCH.BUILD.LIST), and build FULL.LIST
* from 1 to N.
*
    MAX.LIST.ID = CONTROL.LIST<1,3>     ;*Last number written to the list file
    BEGIN CASE
    CASE FULL.LIST = 'initialise' AND MAX.LIST.ID ;* First time - build 'manually'
        FULL.LIST = ''        ;* Ready to populate
        FOR LIST.ID = 1 TO MAX.LIST.ID  ;* So for all IDs
            FULL.LIST<-1> = LIST.ID     ;* Build up internal list
        NEXT LIST.ID
        NUMBER.OF.KEYS = MAX.LIST.ID    ;* This is used when extracting my portion
    CASE FULL.LIST = 'initalise'        ;* First time but no MAX.LIST - belt and braces check
        FULL.LIST = ''        ;* Make sure this is empty!
        CALL EB.READLIST(SEL.CMD, FULL.LIST, '', NUMBER.OF.KEYS, '')  ;* Get the list from the list file

    CASE OTHERWISE  ;* Run out of IDs in full list or session other than the one which has run the .SELECT routine - select to make sure we've done all the keys
        FULL.LIST = ''        ;* Make sure this is empty!
        CALL EB.READLIST(SEL.CMD, FULL.LIST, '', NUMBER.OF.KEYS, '')  ;* Get the list from the list file
    END CASE

    MAX.MISS = INT(NUMBER.OF.KEYS*0.005+1)        ;* When we've 'missed' MAX.MISS records whe reading - then come back and select again
    IF MAX.MISS LT 20 THEN
        MAX.MISS = 20         ;* default
    END

    RETURN
*-----------------------------------------------------------------------------
PROCESS.PORTION:
* Process each list key in my portion

    RECORD.MISS = 0 ;* When we've missed MAX.MISS records - select again
    REMAINING.LIST.KEYS = DCOUNT(ID.LIST,@FM)     ;* Number of list keys in MY portion - check job status when this reduces to LT 20
    LOCK.COUNT = 0  ;*Monitor the number of locks
    END.GAME = 0    ;*Se when all the records are locked
    DISPLAY.MESSAGE = 1       ;* Flag is set to trigger "Available list IDs" message if an agent is waiting for the last record of the job to be processed.
    NO.RECORDS.PROCESSED = 1  ;* Check if atleast one record has been processed..

    LOOP  ;* Process each contract in turn.
        REMOVE LIST.KEY FROM ID.LIST SETTING YDELIM WHILE LIST.KEY:YDELIM AND RECORD.MISS LT MAX.MISS

        REMAINING.LIST.KEYS -=1         ;* Number of keys left in my portion

        LOOP        ;* Loop through each contract in the list record
READ.LOCK.RECORD:
            IF REMAINING.LIST.KEYS LT JOB.THRESHOLD THEN
                GOSUB CHECK.JOB.STATUS  ;* Make sure the job hasn't been finished
                IF EOL THEN   ;* Means another thread has finished the list
                    RETURN    ;* Back to process list
                END
            END
            IF NOT(ACTIVATION.FILE) THEN          ;*LOCKING not present for Activation file
                GOSUB CHK.STILL.HOLD.LIST.FILE    ;* See whether am holding valid list file still
            END
            READU LIST.RECORD FROM F.LIST.NAME, LIST.KEY LOCKED       ;* Record locked so nearing end
                LOCK.COUNT +=1          ;*Number of locks encountered when processing this portion
                IF LOCK.COUNT GE NUMBER.OF.KEYS AND FULL.LIST EQ "" THEN        ;* All list records are locked
                    IF NOT(ACTIVATION.FILE) THEN  ;* END.GAME not required for Activations as there is no dependency to switch to next job and it can continue with the next set of select
                        END.GAME = 1    ;* Ready to sleep
                        IF DISPLAY.MESSAGE THEN   ;*  Available List IDs message is trigerred only once per job and agent.
                            CALL OCOMO('Available list IDs exhausted')
                            DISPLAY.MESSAGE = 0   ;* Reset the flag
                        END
                    END
                END

                BEGIN CASE    ;* When encountering locks - we could be nearing the end of the list
                CASE END.GAME AND CONTROL.LIST<2> = '' AND NOT(LIST.OWNER) AND RUN.AHEAD  ;* Yes near the end of the list (and there's no more lists to build)
                    JOB.INFO = -1       ;* This is the return argument to S.JOB.RUN - it tells SJR to try and run another job
                    CALL OCOMO('Job nearing completion .... Trying to run another job')
                    GOTO PROGRAM.ABORT  ;* Exit immediately
                CASE END.GAME ;* Nearing  the end of this list - but there's another one to build so don't leave this job (sleep and try again)
                    SLEEP.TIME = 5      ;* by default sleep for 5 secs and wait on this record - to avoid repetitive selects/reads
                    IF MAX.LIST.ID > 100 OR CONTROL.LIST<2> THEN      ;* if we have actually written more than 100 records into .LIST file or when next control list exists
                        SLEEP.TIME = 1  ;* then sleep for a short time and try to get the record and distribute it
                    END
                    SLEEP SLEEP.TIME    ;* ; * sleep for the specified time to avoid  repetitive selects/reads
                    JOB.PROGRESS = 6    ;* Waiting on list record
                    CALL SERVICE.HEARTBEAT        ;* Tell the tSM we're ok
                    GOSUB CHECK.SERVICE ;*In case we have been told to finish the job
                    JOB.PROGRESS = 3    ;* Reset incase lock becomes free
                    GOTO READ.LOCK.RECORD         ;* Try again
                CASE OTHERWISE          ;* Just an ordinary clash with another thread
                    RECORD.MISS +=1     ;* Too many of these indicates we might be at the end of the list (ie the other threads have processed the rest)
                    EXIT      ;* Someone else has this list record go onto the next one
                END CASE
            END THEN          ;* We've got it
                IF LIST.RECORD <> '' THEN         ;* BG_100005787 S/E - belt and braces check
                    IF END.GAME OR FULL.LIST = '' THEN      ;* If END.GAME is set / Nearing the end of the list check the JOB.STATUS again
                        GOSUB CHECK.JOB.STATUS    ;* Make sure that ID belongs to the current Job
                        IF EOL THEN     ;* Means another thread has finished the list
                            RETURN      ;* Back to process list
                        END
                    END
                    IF END.GAME THEN    ;*nearing the end of the list
                        IF LIST.RECORD<2> THEN    ;*More than one key in the list
                            GOSUB DISTRIBUTE.LIST.RECORDS   ;*Try to split up the list records
                            RETURN      ;*Go back to do another SELECT
                        END

                    END
                    GOSUB PROCESS.RECORD          ;* Do it then and update the list record too
                    NO.RECORDS.PROCESSED = 0      ;* alteast one record has been processed
                END
                GOSUB GLOBAL.RELEASE    ;*  GB0101735 in case a record routine leaves a lock
            END ELSE
                RELEASE F.LIST.NAME, LIST.KEY     ;* Release in case somebody else has processed
                RECORD.MISS +=1         ;* Too many of these indicates we might be at the end of the list (ie the other threads have processed the rest)
                EXIT          ;* Record has already been processed - go on to the next list record
            END
        WHILE LIST.RECORD     ;* Any contracts left in here
        REPEAT      ;* Next contract
    REPEAT          ;* Next list record

    RETURN
*-----------------------------------------------------------------------------
PROCESS.RECORD:
* Loop through the contract list from the list record and process each contract.


    C$RPT.DEST.PRINTER = SAVE.BATCH.PRINTER       ;*save and restore the vaiable for Default printer
    IF NOT(FORCE.TIMEOUT.LOGOFF)  THEN  ;* Tell the tsa status what we're doing - BUT don't put this in the txn boundary in case the single threader takes too long - you can lock up the tSM ;* CI_10043592 S/E
        JOB.PROGRESS = 7      ;* Single threaded - tells the tSM not to kill me if I take too long
        LAST.CONTACT.TIME = -99         ;* Forces heartbeat to record JOB.PROGRESS
        CALL SERVICE.HEARTBEAT          ;* Update TSA.STATUS
    END

    IF TXN.MGMT THEN          ;* Which is the default
        GOSUB DW.PROCESSING
        CALL EB.TRANS('START',RMSG)     ;* Wrap a transaction around the processing of the contract/bulk contract
    END

    CONTRACT$ID = ''          ;* Initialise
    GOSUB CHECK.SEAT          ;* See if we need to start SEAT tracing
    IF SEAT.TRACE.ON AND R.TSA.STATUS<TS.TSS.CURRENT.SERVICE> NE 'SEAT.INJECTOR' THEN     ;* We're in tracing mode
        SEAT.DETAILS = ''; SEAT.SCRIPT = ''       ;* It needs to be setup everytime to avoid invoking the wrong tests; *CI_10042787/S ; * BG_100011810S/E
        CALL T.SEAT('ON','')  ;* Start the performance trace (only during COB and for other than SEAT.INJECTOR service) - if allowed to; * CI_10042787/E
    END

    ASSIGN 0 TO SYSTEM(1036)  ;* Clear lock collision counter - so the TEC will ignore collisions from BJC
    KEY.TO.PASS = ''          ;* Initialise

    USER.INFO=@USERSTATS      ;* get the current user information
    WRITE.CNT.START=USER.INFO<20>       ;* get the current writes count

*EN_10003752 S
    IF KEYS.ONLY THEN         ;* If this is set on the PGM record then ignore list record just use the key
        CONTRACT.LIST = LIST.KEY
    END ELSE
        CONTRACT.LIST = LIST.RECORD<1>  ;* Take the first field
    END
*EN_10003752 E

    BATCH.THREAD.KEY = LIST.KEY         ;* Store in common - in case of crash
    IF CONTRACT.LIST <> '' THEN         ;* To be sure   ; * BG_100005787 e
        BEGIN CASE
        CASE STANDARD.JOB     ;* Normal MT job
            LOOP REMOVE CONTRACT$ID FROM CONTRACT.LIST SETTING D WHILE CONTRACT$ID <> ''  ;* Handle bulk list of contracts
                IF R.SPF.SYSTEM<SPF.OP.CONSOLE,1> MATCHES 'ON':@VM:'PERFORMANCE':@VM:'TEST':@VM:'RECORD' THEN
                    SEAT.SCRIPT<4,-1> = CONTRACT$ID         ;* CI_10042787 S/E; * BG_100011810S/E  populate the variable only when SEAT is used.
                END
                KEY.COUNT +=1 ;* Maintain a count of the number of contracts this thread has done
                GOSUB CALL.RECORD.ROUTINE         ;* Process the contract
            REPEAT
            GOSUB CHECK.CACHE ;* checks whether the record routine used the cache and write cache updates
            CALL CLEAR.CACHE  ;* MAke sure the cache is cleared up at the end of Bulk list
            SET.CACHE=0       ;* cache off
            GOSUB SET.CACHE.VARIABLES   ;* reset the cache varables

        CASE RECORD.ROUTINE[' ',1,1]='EXECUTE'    ;* Something to execute rather than call
            KEY.COUNT +=1     ;* Maintain a count of the number of contracts this thread has done
            ECOMMAND = RECORD.ROUTINE[' ',2,999]  ;* The command to execute
            CALL OCOMO('Executing... ':ECOMMAND)  ;* Tell the como
            EXECUTE ECOMMAND  ;* Do it
        CASE OTHERWISE        ;* Non-Standard single thread job
            KEY.COUNT +=1     ;* Maintain a count of the number of contracts this thread has done
            IF R.SPF.SYSTEM<SPF.OP.CONSOLE,1> MATCHES 'ON':@VM:'PERFORMANCE':@VM:'TEST':@VM:'RECORD' THEN
                SEAT.SCRIPT<4,-1> = 1   ;* Just dummy flag to enable SEAT for single threaded job,populate the variable only when SEAT is used.
            END

* Single threaded jobs not to use write cache as the cache size is exceeded in the record routine.

            CACHE.OFF = 1     ;* Defaults the F.READ cache to off - the routine can turn it on if it's well behaved
            dasMode = dasReturnResults  ;* DAS should return the results in default

            IF tvMode THEN
                CALL TV.TRANS.GET.START.TIME
            END

            CALL @JOB.ROUTINE ;* SingleThread no arguments ; * BG_100003135

            IF tvMode THEN

                WRITE.PRESENT = ''      ;* check if any write happens
                CACHE.COUNT = DCOUNT(FWT,FM)      ;* count the no of records in the cache
                FOR CNT = 1 TO CACHE.COUNT
                    IF FWF(CNT)[1,1] EQ 'W' THEN  ;* if any write available in cahce then enable WRITE.PRESENT to write a LOG.FILE in capture environment
                        WRITE.PRESENT = 1         ;* say yes for any write otherwsie say it no
                        CNT = CACHE.COUNT         ;* if any write happens then dont loop it again
                    END
                NEXT CNT
                IF WRITE.PRESENT THEN   ;* if any write happens then go and write log file for service txns in capture area and update the TV.SERVICE.TXN.DETAILS record for replay area
                    CALL TV.TRANS.GET.END.TIME    ;* get end time
                    CALL TV.TRANS.STORE.PROCESS   ;* write log file
                END
                CALL TV.TRANS.COMMON.RESET        ;* reset all the commons once record has been written in log file
                tvFieldCheck=''         ;* reset the commons, for a manual transaction coming after the service txns this should have to be null
                tvSplFieldCheck=''      ;* reset the commons, for a manual transaction coming after the service txns this should have have to be null
            END
            CALL CLEAR.CACHE  ;* MAke sure the cache is cleared up - if used
            CACHE.OFF = 1     ;* make sure the cache is off

        END CASE
    END

* Get the lock collision count from the SYSTEM(1036) variable
    COLLISION.COUNT += SYSTEM(1036)<1>

    IF STANDARD.JOB AND KEY.TO.PASS<2> THEN       ;* If a standard m/t job and Incase the record.routine has passed back value
        LIST.RECORD<1> = KEY.TO.PASS<2> ;* Substitute the original value in LIST.RECORD
    END ELSE        ;* either a singleThreaded Job or m/t job and record.routine has not passed back anything
        DEL LIST.RECORD<1>    ;* Drop it

* EN_10003752 S
* If this service is marked to work with keys only then do not
* consider the content of the record. Delete it's content all together
        IF KEYS.ONLY THEN
            LIST.RECORD = "";
        END
*EN_10003752 E
    END

    IF LIST.RECORD <> '' THEN ;* Still have contracts left in this list record
        WRITE LIST.RECORD TO F.LIST.NAME, LIST.KEY          ;* Write it back with one contract less
        WRITE.CNT.START+=1    ;* exclude this write operation as we need to get the writes happened in the record routine of the job
    END ELSE        ;* Empty list
        DELETE F.LIST.NAME, LIST.KEY    ;* Signal we've done this list record
    END

    IF TXN.MGMT THEN
        CALL EB.TRANS('END',RMSG)       ;* Commit it
        USER.INFO=@USERSTATS  ;* get the user stats information
        WRITE.CNT.END=USER.INFO<20>     ;* get the writes count now
        GOSUB DW.PROCESSING
    END ELSE
        USER.INFO=@USERSTATS  ;* get the user stats information
        WRITE.CNT.END=USER.INFO<20>     ;* get the writes count now
    END

    ACTUAL.WRITES=WRITE.CNT.END-WRITE.CNT.START   ;* get the no.of. writes done in the record routine of the job.
    TOTAL.WRITES=TOTAL.WRITES+ACTUAL.WRITES       ;* add it to the writes count

    IF SEAT.TRACE.ON AND R.TSA.STATUS<TS.TSS.CURRENT.SERVICE> NE 'SEAT.INJECTOR' THEN     ;* Analyse the trace if we've made one and if service is not SEAT.INJECTOR
        SEAT.DETAILS<1> = JOB.NAME      ;* stores the JOB NAME
        SEAT.DETAILS<7> = JOB.NAME      ;* JOB.NAME - key to F.SEAT for the test routines
        SEAT.DETAILS<2> = PROCESS.NAME  ;* Pass the Process name
        SEAT.DETAILS<5> = SEAT.SCRIPT<3>          ;* The ofs message - that should be stored in the SEAT.RESULTS file
        SEAT.DETAILS<3> = SEAT.SCRIPT<4>          ;* The Id of the transaction current transaction being processed.
        SEAT.DETAILS<6> = SEAT.SCRIPT<6>          ;* Company to which the script to be loaded

        CALL T.SEAT('FINISH',SEAT.DETAILS)        ;* Stop the performance trace definitely - if allowed to (only during COB and service)
    END

    LISTS.PROCESSED +=1       ;* We've done another list
    IF TIME() - STIME GE REVIEW.TIME OR TIME() < STIME THEN ;* Report progress every minute or over midnight EN_10001864 s/e
        STIME = TIME()        ;*Initialise the Start Time
        GOSUB UPDATE.STATUS   ;* Update the como /job times
        LIST.RECORD = ''      ;*Force it to go to the next JOB.LIST record CI_10048043 S/E
        GOSUB CHECK.SERVICE   ;*Check we are still ok to run the agent
    END

    RETURN

*-----------------------------------------------------------------------------
CHECK.SEAT:
* See if we need to SEAT trace the routine

    BEGIN CASE
    CASE R.SEAT.TEST = ''     ;* No tracing
        SEAT.TRACE.ON=0
    CASE PROCESS.NAME = R.SEAT.TEST     ;* Trace all jobs in this process
        SEAT.TRACE.ON=1
    CASE PROCESS.NAME:'-':JOB.NAME = R.SEAT.TEST  ;* Trace this job in this process
        SEAT.TRACE.ON=1
    CASE OTHERWISE
        SEAT.TRACE.ON=0
    END CASE

    RETURN
*-----------------------------------------------------------------------------
CALL.RECORD.ROUTINE:
* Invoke the record routine passing the contract



    BATCH.THREAD.KEY = LIST.KEY:' ':CONTRACT$ID   ;* Store in common - in case of crash
    KEY.TO.PASS = CONTRACT$ID ;* Copy in case the routine changes it
    GOSUB CHECK.COMPANY       ;* Read the contract record and pick up the company code - in case we're multi-book

    SET.CACHE=1     ;* cache on
    GOSUB SET.CACHE.VARIABLES ;* set the cache varables


    IF tvMode THEN
        CALL TV.TRANS.GET.START.TIME
    END

    dasMode = dasReturnResults          ;* DAS should return the results in default
    CALL @RECORD.ROUTINE (KEY.TO.PASS)  ;* Do it - MultiThread

    GOSUB CHECK.RECORD.VERIFICATION     ;* check whether the record routine has verification mechanism

    BATCH.THREAD.KEY = ''     ;* Finished contract - clear in case there's a fatal error anywhere else
    IF tvMode THEN
        CALL TV.TRANS.GET.END.TIME
        CALL TV.TRANS.STORE.PROCESS
        CALL TV.TRANS.COMMON.RESET
    END

    RETURN
*-----------------------------------------------------------------------------
UPDATE.STATUS:
* Update the como, job times and check that the service hasn't changed
*
    CALL OCOMO(OCONV(TIME(),'MTS'):' Processed ':LISTS.PROCESSED:' lists [':LISTS.PROCESSED-LAST.LIST.COUNT:']')
    LAST.LIST.COUNT = LISTS.PROCESSED

    CALL SERVICE.HEARTBEAT    ;* Tell the tSM we're ok
    JOB.OPERATION = 'PROGRESS'          ;* Tell the job times file how we're doing
    GOSUB UPDATE.JOB.TIMES    ;*Update the job times of our progress so far
* Update Temenos Enterprise Console with JOB.PROGRESS event
    GOSUB UPDATE.TEC.JOB.PROGRESS
    RETURN

*-----------------------------------------------------------------------------
CHECK.SERVICE:
* Check whether the agent is still active and is scheduled to run the current service
*

    READ R.TSA.STATUS FROM F.TSA.STATUS, AGENT.NUMBER THEN  ;* Check our service hasn't changed
        IF R.TSA.STATUS<TS.TSS.AGENT.STATUS> # 'RUNNING' THEN
            GOTO PROGRAM.END  ;* Agent has been stopped
        END
        IF R.TSA.STATUS<TS.TSS.NEXT.SERVICE> THEN
            IF R.TSA.STATUS<TS.TSS.NEXT.SERVICE> # R.TSA.STATUS<TS.TSS.CURRENT.SERVICE> THEN
                GOTO PROGRAM.END        ;* Get out of here
            END
        END
    END

    RETURN
*-----------------------------------------------------------------------------
CHECK.JOB.STATUS:
* Continually check the batch status record for the job (at the end of the list).
* If any thread completes then we need to exit immediately - because
* a) It's quicker and b) we don't want to find we're somehow processing
* list records meant for another job which might just happen.

    IF NOT(ACTIVATION.FILE)  THEN       ;*For Activation jobs there is no control list

        READ CURRENT.CONTROL.LIST FROM F.BATCH.STATUS, FLAG.ID ELSE NULL        ;* Check the job status

        IF CURRENT.CONTROL.LIST=PROCESSED THEN    ;* Finished by another thread
* If the job has been finished by another agent , update the END stage details to JOB.TIMES record.

            CALL EB.TRANS('START',RMSG)
            JOB.OPERATION = 'END ': TIME()        ;* End of job time
            GOSUB UPDATE.JOB.TIMES      ;* update the END stage details in JOB.TIMES
            CALL EB.TRANS('END',RMSG)

            CALL OCOMO( 'Job finished by another agent')
            RELEASE ;* Make sure we haven't got any locks
            GOTO PROGRAM.ABORT          ;* Back to S.JOB.RUN immediately - our job is over
        END
        IF CURRENT.CONTROL.LIST<1,1> # CONTROL.LIST<1,1> THEN         ;* Means another thread has finished this list and is building the next
            EOL = 1 ;* Flag that we're at the end of this list. This will send control back to 'advance control list'
        END
    END

    RETURN
*-----------------------------------------------------------------------------
GLOBAL.RELEASE:
* When returning from the record routine ensure that no locks are left. Ideally
* the record routine should either write or release any locked records. However,
* if it doesn't then the lock table could easily fill up and the job crash.
* Do it after processing every record routine

    RELEASE         ;* Global release incase the record routine left a lock

    RETURN
*-----------------------------------------------------------------------------
INITIALISE:

    MAT C$SC = ''   ;* Initialise the shared common area for the job's load & run routines

    BATCH.THREAD.KEY = ''     ;*Initialise the common variable
    JOB.NAME = JOB.INFO['_',1,1]        ;* Key to PGM.FILE
    JOB.ROUTINE = JOB.INFO['_',2,1]     ;* Routine to call
    ACTIVATION.FILE = JOB.INFO['_',3,1] ;* If it's a permanent agent (like delivery - it will have it's on list/activation file)
    JOB.POSITION = JOB.INFO["_",4,1]    ;* Position of the job in R.BATCH - needed in case the same job name appears in the batch record
    SELECT.AHEAD = JOB.INFO["_",5,1]    ;* Run the select part only - enables list preparation while another job is running
    PROCESSING = 'processing' ;* Used for checking state of control list
    PROCESSED = 'processed'
    EMPTYLIST = 'emptylist'   ;* Signals an empty list

    GOSUB INITIALISE.MULTI.BOOK         ;* Prepare for multi-book processing

    IF JOB.ROUTINE = '' OR JOB.ROUTINE = 'BATCH.JOB.CONTROL' THEN     ;* Identify whether MT job or not
        STANDARD.JOB = 1      ;* Normal mt job
    END ELSE
        STANDARD.JOB = 0      ;* Single thread job
    END

    IF INDEX(R.PGM.FILE<EB.PGM.ADDITIONAL.INFO>,".NUC",1) THEN        ;* check if the job wants to use the cache or not
        USE.CACHE=0 ;* dont'use the cache
    END  ELSE
        USE.CACHE=1 ;* use the cache
    END

    BEGIN CASE
    CASE JOB.NAME = 'EB.EOD.REPORT.PRINT'         ;*  we do not call EB.TRANS, if JOB.NAME is EB.EOD.REPORT.PRINT
        TXN.MGMT = 0          ;* No txn management
        USE.CACHE=0 ;* dont'use the write cache as there is no transaction management
    CASE INDEX(R.PGM.FILE<EB.PGM.ADDITIONAL.INFO>,".NTX",1) ;* No txn mgmt - R.PGM.FILE read in INITIALISE.MULTI.BOOK
        TXN.MGMT = 0
        USE.CACHE=0 ;* dont'use the write cache for ".NTX" jobs as the transaction mgmt is not started here in BJC
    CASE OTHERWISE
        TXN.MGMT = 1          ;* Default transaction management to be on
    END CASE


    IF INDEX(R.PGM.FILE<EB.PGM.ADDITIONAL.INFO>,".NOL",1) THEN        ;*If .NOL is set at Version level
        R.VERSION(EB.VER.REPORT.LOCKS) = 'NO'     ;*Set the value as NO so that no reporting is done on locks
    END

*EN_10003752 s
    KEYS.ONLY = 0;
    IF INDEX(R.PGM.FILE<EB.PGM.ADDITIONAL.INFO>,".KEY",1) THEN        ;*If .KEY then just work with keys in the activation file, ignore records.
        KEYS.ONLY = 1;
    END
*EN_10003752 e

    SELECT.ROUTINE = JOB.NAME: '.SELECT'
    RECORD.ROUTINE = JOB.NAME
    LOAD.ROUTINE = JOB.NAME: '.LOAD'

    IF STANDARD.JOB THEN      ;* It's ok to call the load routine
        CALL OCOMO('Standard multi-thread job')
        CALL OCOMO('Calling load routine')        ;* Tell 'em in the como
        dasMode = dasReturnResults      ;* DAS should return the results in default
        CALL @LOAD.ROUTINE    ;* Load the common area for use by the record routine
    END ELSE
        CALL OCOMO('Single Thread routine ':RECORD.ROUTINE) ;* BG_100002910 S/E
    END

    FLAG.ID = PROCESS.NAME:'-':RECORD.ROUTINE:'-':JOB.POSITION        ;* BG_100005787 ends

    FN.BATCH.STATUS = 'F.BATCH.STATUS'
    F.BATCH.STATUS = ''
    CALL OPF(FN.BATCH.STATUS, F.BATCH.STATUS)
    BATCH.COMPANY = ID.COMPANY          ;* EN_10001831 store the original company of the Batch job

    FN.LIST.NAME = ''         ;*Initialise the variable as this is now being refered even before allocation.

    LIST.OWNER = 0  ;* To identify the session allocating the .LIST file

    CALL OPF('F.JOB.TIMES',F.JOB.TIMES)

    CALL OPF('F.JOB.TIMES.HISTORY',F.JOB.TIMES.HISTORY)     ;* open the job times history file
    R.JOB.TIMES.HISTORY = ''  ;* record to hold the JOB.TIMES.HISTORY details

    GOSUB OPEN.LIST.FILE      ;* And open the list file for processing

    READ R.TSA.STATUS FROM F.TSA.STATUS, AGENT.NUMBER ELSE  ;* All from TSA.COMMON - status record used for info for tEC
        R.TSA.STATUS = ""
    END

    READ R.TSA.SERVICE FROM F.TSA.SERVICE, R.TSA.STATUS<TS.TSS.CURRENT.SERVICE> ELSE      ;*get the Service record
        R.TSA.SERVICE = ''
    END
* Review time defined in TSA.SERVICE takes priority over TSA.PARAMETER
    IF R.TSA.SERVICE<TS.TSM.REVIEW.TIME> NE '' THEN         ;*review time set in TSA.SERVICE
        SERVICE.REVIEW.TIME = R.TSA.SERVICE<TS.TSM.REVIEW.TIME>       ;*take it
    END ELSE
        SERVICE.REVIEW.TIME = R.TSA.PARAMETER<TS.PARM.REVIEW.TIME>    ;*review time defined at TSA.PARAMETER
    END

    REVIEW.TIME = 60          ;* Default every minute for JOB.TIMES Update

* Read the Locking record with the id as 'SEAT.TRACE' only if SEAT is on.

    R.SEAT.TEST  = ''         ;* initialise the variable to hold the SEAT.TRACE record

    IF R.SPF.SYSTEM<SPF.OP.CONSOLE,1> MATCHES 'ON':@VM:'PERFORMANCE':@VM:'TEST':@VM:'RECORD' THEN   ;* seat turned on
        READ R.SEAT.TEST FROM F.LOCKING, 'SEAT.TRACE' ELSE  ;* See if we've been asked to trace a particular job/contract
            R.SEAT.TEST = PROCESS.NAME:'-':JOB.NAME         ;* This means trace ALL jobs
        END
    END

    R.SEAT.TEST = R.SEAT.TEST["-",1,2]  ;* Drop any contract specification - this can no longer be supported

    NUMBER.OF.SESSIONS = R.TSA.PARAMETER<TS.PARM.HIGHEST.AGENT>       ;* Last session running - initially
    LISTS.PROCESSED = 0       ;* Keep a count of lists processed
    LAST.LIST.COUNT = 0       ;* So we can show throughput
    KEYS.PROCESSED = 0        ;* Comes from BATCH.BUILD.LIST via the select routine
    STIME = TIME()  ;* Start of job - select or processing
    KEY.COUNT = 0   ;* Number of individual contracts processed by this thread
    KTIME = TIME()  ;* Used to calculate single thread throughput
    LAST.COMPLETED = 0        ;* Used to calculate current total throughput
    IF ACTIVATION.FILE THEN   ;* Permanent agent
        LIST.SAMPLE = 100     ;* Just take a few
    END ELSE
        LIST.SAMPLE = 100000  ;* COB - take a load
    END
    JOB.THRESHOLD = 100       ;* As a safety measure we check the batch.status for the last 100 record in a extracted portion
    FASTEST.THROUGHPUT =0     ;* Stored in job times - shows fastest throughput/min achieved for the job

    IF LAST.JOB EQ JOB.INFO THEN        ;* If it same job dont try to Run Ahead
        RUN.AHEAD = 0         ;* We've already looked once and there was nothing to do
    END ELSE
        RUN.AHEAD = 1
    END
    LAST.JOB = JOB.INFO       ;* Keep this in common so we know if we've come back from running (or selecting) ahead

    IF R.TSA.STATUS<TS.TSS.CURRENT.SERVICE>[1,3] NE  'COB' THEN       ;* Run ahead available only for COB
        RUN.AHEAD = 0         ;* if it's an Online Service flag RUN.AHEAD to false
    END

    CALL EB.READ.SPF          ;* BG_100005037 Get the correct OP.MODE

    SET.COLLECT = 0
    DW$EXTRACT.MODE = 1

    FORCE.TIMEOUT.LOGOFF = 1  ;* set the timeout logoff to true
    IF NOT(STANDARD.JOB) OR JOB.NAME = 'EB.EOD.REPORT.PRINT' OR JOB.NAME = 'RUN.CONVERSION' OR JOB.NAME = 'ARC.STATEMENT' THEN    ;* if not a std job or job is report printing or run conversion  or arc statement(archiving) then
        FORCE.TIMEOUT.LOGOFF = 0        ;* set forced time out logoff to false
    END
    SAVE.BATCH.PRINTER = C$RPT.DEST.PRINTER       ;*save the varaible for Default printer
    BULK.NUMBER=0   ;* intialise the common variable which holds the no.of contracts to be bulked
    SELECT.STATEMENT=''       ;* initialise the common variable which holds the select statement
    SELECTION.MODE=''         ;* initialise the common variable which holds the selection type(ALL,PREDEFINED,CRITERIA,FILTER)
    COLLISION.COUNT=0         ;* Keep a count on the no.of.collisions
    RECORD.VERIFICATION=''    ;* Whether the record routine has the mechanism to process or eliminate keys
    JOB.START.TIME=''         ;* initialise the start time variable
    ROUTINE.USED.CACHE= ''    ;* indicates whether the record routine has actually used the cache or not
    TOTAL.WRITES=0  ;* Keep a count on the no.of writes
    ACTUAL.WRITES=0 ;* no of writes count during each record routine processing
    JOB.TIMES.END = 0         ;* Flag to indicate whether JOB.TIMES has been ended

    RETURN
*-----------------------------------------------------------------------------
INITIALISE.MULTI.BOOK:

* read the PGM.FILE record to pick upthe file to read so the correct company can be loaded
*
    CALL OPF("F.PGM.FILE",F.PGM.FILE)   ;* read the PGM.FILE record to pick upthe file to read so the correct company can be loaded
    READ R.PGM.FILE FROM F.PGM.FILE, JOB.NAME ELSE R.PGM.FILE = ""
    FN.KEY.FILE = "" ; F.KEY.FILE = ""
*
* BG_10004694 improve key definition for multi book
*
    IF R.PGM.FILE<EB.PGM.MT.KEY.FILE> AND C$MULTI.BOOK THEN
        KEY.FILE = R.PGM.FILE<EB.PGM.MT.KEY.FILE>
*
* get the standard selection record to pick up the company code
*
        R.STANDARD.SELECTION = ''
        SS.ID = FIELD(KEY.FILE,'$',1)   ;* CI_10037219
        CALL GET.STANDARD.SELECTION.DETS(SS.ID,R.STANDARD.SELECTION)  ;* CI_10037219
        IF R.STANDARD.SELECTION THEN
            IF FN.KEY.FILE[1,2] NE "F." THEN FN.KEY.FILE = "F.":KEY.FILE
            CALL OPF(FN.KEY.FILE,F.KEY.FILE)
            FIELD.NME = "CO.CODE"
            CO.FIELD.NO = ''
            DATA.TYPE = ''
            ERR.MSG = ''
            YYAF = '' ; YYAV = '' ; YYAS = ''
            CALL FIELD.NAMES.TO.NUMBERS(FIELD.NME,R.STANDARD.SELECTION,CO.FIELD.NO,YYAF,YYAV,YYAS,DATA.TYPE,ERR.MSG)
            IF NOT(ERR.MSG) THEN
                R.CO = ""
                FIELD.SPEC = "1X0X>1X0X"          ;* CUSTOMER>SECTOR
                IF MATCHFIELD(CO.FIELD.NO,FIELD.SPEC,1) THEN
                    CO.FLD = "JOIN"
                END ELSE
                    CO.FLD = "DATA"
                    FNO = CO.FIELD.NO[".",1,1]
                    VNO = CO.FIELD.NO[".",2,1] ; IF VNO = "" THEN VNO = 1
                    SNO = CO.FIELD.NO[".",3,1] ; IF SNO = "" THEN SNO = 1
                END
                CALL OPF("F.COMPANY",F.COMPANY)
                KEY.COMPONENT = R.PGM.FILE<EB.PGM.MT.KEY.COMPONENT>
                IF KEY.COMPONENT THEN
                    KEY.POS.1 = FIELD(KEY.COMPONENT,",",1)
                    KEY.POS.2 = FIELD(KEY.COMPONENT,",",2)
                END ELSE
                    KEY.POS.1 = ""
                    KEY.POS.2 = ""
                END
            END ELSE
                FN.KEY.FILE = ""
            END
        END
    END

    RETURN
*-----------------------------------------------------------------------------
EXTRACT.PORTION:
* To avoid each thread processing the same part of the list extract a portion
* based on my session number (1 to NUMBER.OF.SESSIONS)

    READ R.TSA.PARAMETER FROM F.TSA.PARAMETER, 'SYSTEM' THEN
        NUMBER.OF.SESSIONS = R.TSA.PARAMETER<TS.PARM.HIGHEST.AGENT>   ;* Last session running
    END ELSE
        NUMBER.OF.SESSIONS = 10         ;* default
    END

    IF SESSION.NO GT NUMBER.OF.SESSIONS THEN      ;* Just in case
        NUMBER.OF.SESSIONS += SESSION.NO          ;* Always make sure this session is less than the max - otherwise the maths won't work
    END

    NUMBER.OF.KEYS = DCOUNT(FULL.LIST,@FM)        ;* Number of keys in the list
    NUMBER.TO.PROCESS = NUMBER.OF.KEYS/NUMBER.OF.SESSIONS   ;* my thread should process
    OFFSET = INT((NUMBER.TO.PROCESS * SESSION.NO)- NUMBER.TO.PROCESS) ;* My portion of the list

    IF NUMBER.OF.KEYS > NUMBER.OF.SESSIONS THEN   ;* If list is big enough
        ID.LIST = FULL.LIST[@FM,OFFSET,INT(NUMBER.TO.PROCESS)]        ;* Extract it
        FULL.LIST = FULL.LIST[@FM,OFFSET+INT(NUMBER.TO.PROCESS),NUMBER.OF.KEYS]
        IF OFFSET GT 1 THEN   ;* Wasn't the first id in the list
            FULL.LIST:= @FM: FULL.LIST[@FM,1,OFFSET-1]      ;* Reduce the full list accordingly - reverse build to avoid clashes
        END
    END ELSE
        ID.LIST = FULL.LIST   ;* Take the lot - we're too near the end to worry
        FULL.LIST = ''        ;* This will force the select again to make sure we've mopped up all ids
        MAX.MISS = NUMBER.OF.KEYS       ;* Force End Game - when all IDs are locked
    END

    RETURN
*----------------------------------------------------------------------------------
CHECK.COMPANY:
* How do we easily define the field the company code is in?
* and how can we do this quickly - you're supposed to work that out before you write the code Phil!

    IF FN.KEY.FILE THEN
        CHECK.KEY = KEY.TO.PASS
        IF KEY.POS.1 NE '' THEN
            IF NUM(KEY.POS.1) THEN
                CHECK.KEY = KEY.TO.PASS[KEY.POS.1,KEY.POS.2]
            END ELSE          ;* field type
                CHECK.KEY = FIELD(KEY.TO.PASS,KEY.POS.1,KEY.POS.2,1)
            END
        END
        READ KEY.REC FROM F.KEY.FILE, CHECK.KEY THEN
            IF CO.FLD = "JOIN" THEN
                CALL FIELD.JOIN(KEY.FILE,CHECK.KEY,KEY.REC,CO.FIELD.NO,KEY.COMPANY)
            END ELSE
                KEY.COMPANY = KEY.REC<FNO,VNO,SNO>
            END
            IF KEY.COMPANY NE ID.COMPANY THEN
                READ R.CO FROM F.COMPANY, KEY.COMPANY THEN
                    CALL LOAD.COMPANY(KEY.COMPANY)
                END
            END
        END
    END

    RETURN
*----------------------------------------------------------------------------------
UPDATE.JOB.TIMES:
* Update the job times file (used to be done in S.BATCH.RUN). Create a new m/value if we're
* starting the job, maintain the number of keys to be processed and update the end time
* when we're finished. The transaction management occurs aroud this gosub.
*
* Get the selection details and the no.of records bulked.
* Retrieve the common variables BULK.NUMBER,SELECT.STATEMENT,SELECTION.MODE set
* in BATCH.BUILD.LIST and update the fields in JOB.TIMES when JOB.OP ='KEYS'
* For single threaded job,these values would be one set in the initilaisation.
* SELECT.TIME,PROCESSED, and COMPLETED will now be assoc.sub value fields to store
* the information for each control list.
*

    IF INDEX(R.PGM.FILE<EB.PGM.ADDITIONAL.INFO>,".NJT",1) THEN        ;* Do not update JOB.TIMES for the service, when the field ADDITIONAL.INFO in PGM.FILE is udpated with ".NJT(No Job Times)"
        RETURN
    END
    JT.ID = PROCESS.NAME:'-':JOB.NAME   ;* PROCESS.NAME comes from common I_BATCH.FILES
    JOB.OP = JOB.OPERATION[" ",1,1]     ;* What do you want to do
    JOB.VALUE = JOB.OPERATION[" ",2,1]  ;* And what's the value

    IF JOB.OP = 'PROGRESS' THEN         ;* Don't hang on the lock for progress
        READU R.JOB.TIMES FROM F.JOB.TIMES, JT.ID LOCKED    ;* If it's already locked
            RETURN  ;* go straight beck and don't wait
        END ELSE
            RETURN  ;* Can't be null
        END
    END ELSE
        IF JOB.OP = "END" AND FASTEST.THROUGHPUT EQ 0 THEN  ;*Check if Job is ended with no contracts processed
            READU R.JOB.TIMES FROM F.JOB.TIMES,JT.ID LOCKED ;*I may not update it as it locked already
                RETURN        ;* Stop updating
            END ELSE
                NULL          ;* continue the process
            END
        END ELSE
            READU R.JOB.TIMES FROM F.JOB.TIMES, JT.ID ELSE  ;* Always wait for a lock
                R.JOB.TIMES = ""
            END
        END
    END

    BEGIN CASE
    CASE JOB.OP = 'START'     ;* Starting the job
        R.JOB.TIMES<EB.JT.JOB> = JOB.NAME
        R.JOB.TIMES<EB.JT.PROGRAM> = 'BATCH.JOB.CONTROL'    ;* This will always be the case now
        R.JOB.TIMES<EB.JT.SERVICE.NAME> = R.TSA.STATUS<TS.TSS.CURRENT.SERVICE>  ;*get the service name

        FOR JIDX = EB.JT.BATCH.DATE TO EB.JT.REC.VERIFY     ;* Push current times down  EN_10001864 s/e
            INS '' BEFORE R.JOB.TIMES<JIDX,1>     ;* New time will be stored in 1
            DEL R.JOB.TIMES<JIDX,11>    ;* And drop the 11th as we only want to keep the last 10
        NEXT JIDX

        R.JOB.TIMES<EB.JT.BATCH.DATE,1> = C$BATCH.START.DATE          ;* From INITIALISATION = bank date
        R.JOB.TIMES<EB.JT.SELECT.START,1> = JOB.VALUE       ;* The time the select part started

        GOSUB CHECK.TXN.MGMT  ;* check if the job is run within the transaction management
        R.JOB.TIMES<EB.JT.LOCK.COLLISION,1> = 0   ;* incase if the keys selected is '0',record routine would not be called so set it to '0' initially.
        R.JOB.TIMES<EB.JT.TOTAL.WRITE,1> = 0      ;* incase if the keys selected is '0'

    CASE JOB.OP = 'KEYS'      ;* Done the select - how many keys (contracts!!) do we have
        IF JOB.VALUE LT 0 THEN JOB.VALUE = 0      ;* KEYS.PROCESSED will be equal -1, if BBL is not called at all

        INS JOB.VALUE BEFORE R.JOB.TIMES<EB.JT.PROCESSED,1,1>         ;* In case the select program has been called more than once(CONTROL.LIST logic),include a subvalue for each control list
        INS SELECT.TIME BEFORE R.JOB.TIMES<EB.JT.SELECT.TIME,1,1>     ;* Store the time taken to do the select
        INS SAVE.CONTROL.LIST<1,1>[1,35] BEFORE R.JOB.TIMES<EB.JT.CONTROL.LIST,1,1>       ;*first 35 caharcters
        INS BULK.NUMBER BEFORE R.JOB.TIMES<EB.JT.BULK.NUMBER,1,1>     ;* update the no.of contracts bulked
        INS SELECTION.MODE BEFORE R.JOB.TIMES<EB.JT.TYPE.OF.SEL,1,1>  ;* update the selection mode
        INS SELECT.STATEMENT BEFORE R.JOB.TIMES<EB.JT.SEL.STATEMENT,1,1>        ;* update the select statement used fo
        INS 0 BEFORE R.JOB.TIMES<EB.JT.COMPLETED,1,1>       ;* no.of contracts completed processing
        IF STANDARD.JOB THEN  ;* do it for multithreaded job.Need not do it for a single threaded job.
            GOSUB CLEAR.SELECTION.VARIABLES       ;* clear the common variables set in BATCH.BUILD.LIST
        END

* If the records selected is zero and if there are no more items to be processed in the CONTROL.LIST ,
* then Update the JOB.TIMES with the end part as well.

        IF JOB.VALUE EQ 0 AND CONTROL.LIST = PROCESSED THEN ;* Zero records selected and no more items to be processed
            IF NOT(JOB.START.TIME) THEN
                JOB.START.TIME = TIME() ;* job start time
            END
            END.TIME = TIME() ;* end time
            GOSUB STORE.JOB.END.TIME    ;* end the JOB.TIMES
            JOB.TIMES.END = 1 ;* job times ended
        END

    CASE JOB.OP = 'PROGRESS'  ;* Tell em how we're doing so far
        IF R.JOB.TIMES<EB.JT.START.TIME,1> = "" THEN        ;* I'm first so update the start of the job - note the start of the select is held separately
            R.JOB.TIMES<EB.JT.START.TIME,1> = JOB.START.TIME          ;* Recorded when we began really processing
        END

        GOSUB UPDATE.TOTAL.WRITES       ;* update the writes count and lock collision count

        GOSUB CALL.TEC        ;* Tell the TEC ;* Uses KEY.COUNT for the number of contract processed by this agent
        GOSUB STORE.JOB.PROGRESS        ;* Job times progress
        GOSUB UPDATE.PROGESS.BATCH.STATUS         ;* Batch status
    CASE JOB.OP = 'END' AND R.JOB.TIMES<EB.JT.END.TIME,1> = ""  AND JOB.START.TIME NE ''  ;* And nobody else has done this.The agent trying to end the job first has atleast processed a record or has done the selection of the job
        GOSUB UPDATE.TOTAL.WRITES       ;* Very quickly run - didn't get time for update progress.update the writes count and lock collision count
        KEY.COUNT = SUM(R.JOB.TIMES<EB.JT.PROCESSED,1>) - SUM(R.JOB.TIMES<EB.JT.COMPLETED,1>)       ;* Final number of contracts processed
        GOSUB CALL.TEC        ;* Tell the TEC
        END.TIME = JOB.VALUE  ;* Time we've finished
        GOSUB STORE.JOB.END.TIME        ;* Update end time, throughput etc
    CASE JOB.OP = 'END'       ;* But not the first thread to end
        GOSUB UPDATE.TOTAL.WRITES       ;* Very quicky run and other thread has ended the job. update the writes count and lock collision count
        IF FASTEST.THROUGHPUT GT R.JOB.TIMES<EB.JT.FASTEST,1> THEN    ;* contracts per second per thread
            R.JOB.TIMES<EB.JT.FASTEST,1> = FASTEST.THROUGHPUT         ;* Store the fastest single throughput
        END
    END CASE

    WRITE R.JOB.TIMES TO F.JOB.TIMES, JT.ID       ;* Save it

* Update JOB.TIMES.HISTORY if only SEAT is turned 'ON'
    IF R.SPF.SYSTEM<SPF.OP.CONSOLE,1> MATCHES 'ON':@VM:'PERFORMANCE':@VM:'TEST':@VM:'RECORD' THEN   ;* SEAT turned 'ON'
        R.JOB.TIMES.HISTORY=R.JOB.TIMES ;* get the record
        JOB.TIMES.HIST.ID=JT.ID:'-':TODAY:'-':TIME()
        WRITE R.JOB.TIMES.HISTORY ON F.JOB.TIMES.HISTORY,JOB.TIMES.HIST.ID      ;* write it
    END

    RETURN
*-----------------------------------------------------------------------------
CALL.TEC:
* Tell the TEC how many contract we've processed. The item is TXN.METRIC.
* R.TSA.STATUS is in common - so should be available here - and it's read in BJC as well

    IF KEY.COUNT GT 0 THEN    ;* Just in case
        CALL TEC.RECORD.ACTIVITY('TXN.METRIC',R.TSA.STATUS<TS.TSS.CURRENT.SERVICE>,'',KEY.COUNT)    ;* Tell the TEC how many we've done
        IF JOB.OP EQ 'END' THEN         ;* Check if Job is ended
            PROCESSED.KEYS.COUNT = R.JOB.TIMES<EB.JT.PROCESSED,1>     ;* get the keys processed
            CALL SERVICE.CONTROL('',PROCESSED.KEYS.COUNT,'')          ;* And update the service history as well
        END
    END
    RETURN
*-----------------------------------------------------------------------------
STORE.JOB.PROGRESS:
* Maintain the throughput and key count of the job on JOB.TIMES.

    R.JOB.TIMES<EB.JT.COMPLETED,1,1> += KEY.COUNT ;* Number of contracts processed so far
    ETIME = TIME()-KTIME      ;* Number of seconds since the last time we updated the progress

    IF ETIME > 0 THEN
        IF LAST.COMPLETED THEN          ;* Calculate overall throughput if you have something
            PROCESSED.THIS.SLICE = R.JOB.TIMES<EB.JT.COMPLETED,1,1> - LAST.COMPLETED
            R.JOB.TIMES<EB.JT.THROUGHPUT,1> = INT(PROCESSED.THIS.SLICE / (ETIME/REVIEW.TIME))       ;* Overall throughput
        END
        CURRENT.THROUGHPUT = INT(KEY.COUNT / (ETIME/REVIEW.TIME))     ;* My throughput in minutes
        IF CURRENT.THROUGHPUT > FASTEST.THROUGHPUT THEN     ;* Faster than before
            FASTEST.THROUGHPUT = CURRENT.THROUGHPUT         ;* Save this
        END
        IF KEY.COUNT THEN     ;* Providing we've done something
            MY.AVERAGE.RESPONSE = ETIME/KEY.COUNT ;* Calculate the average response time per transaction
            MY.AVERAGE.RESPONSE = INT(MY.AVERAGE.RESPONSE*1000)/1000  ;* Only to three decimal places
            IF MY.AVERAGE.RESPONSE > R.JOB.TIMES<EB.JT.HIGHEST.RESPONSE,1> THEN ;* Highest so far
                R.JOB.TIMES<EB.JT.HIGHEST.RESPONSE,1> = MY.AVERAGE.RESPONSE     ;* Save it
            END
        END
    END

    KTIME = TIME()  ;* Ready for next time
    KEY.COUNT = 0   ;* Reset for next
    LAST.COMPLETED = R.JOB.TIMES<EB.JT.COMPLETED,1,1>       ;* So we can calculate ongoing throughput
    AGENT.LIST = R.JOB.TIMES<EB.JT.AGENTS,1>      ;* List of agents running this job
    CONVERT ',' TO @FM IN AGENT.LIST    ;* So we can locate
    LOCATE SESSION.NO IN AGENT.LIST<1> SETTING APOS ELSE    ;* Are we in here?
        AGENT.LIST<-1> = SESSION.NO     ;* Add me to the list
        CONVERT @FM TO ',' IN AGENT.LIST          ;* Ready to store back in job times
        R.JOB.TIMES<EB.JT.AGENTS,1> = AGENT.LIST  ;* Store for display whilst running
    END

    RETURN
*------------------------------------------------------------------------
STORE.JOB.END.TIME:
* We're the first agent to finish the job - Calculate the final throughput, end time etc

    IF R.JOB.TIMES<EB.JT.START.TIME,1> = "" THEN  ;* We've finished before we had a chance to log some progress
        R.JOB.TIMES<EB.JT.START.TIME,1> = JOB.START.TIME    ;* Recorded as we came in
    END

    IF ROUTINE.USED.CACHE  THEN         ;*  the record routine used cache
        R.JOB.TIMES<EB.JT.READ.WRITE.CACHE,1> = 'Y'         ;*   set the READ.WRITE.CACHE field to 'Y'
    END ELSE
        R.JOB.TIMES<EB.JT.READ.WRITE.CACHE,1> = 'N'         ;* set the READ.WRITE.CACHE field to 'N'
    END

    IF RECORD.VERIFICATION THEN         ;* if the job has verification mechanism
        R.PGM.FILE=''         ;* record to hold the PGM.FILE details
        READU R.PGM.FILE FROM F.PGM.FILE,JOB.NAME LOCKED    ;* read and lock the PGM.FILE record.
        END THEN
            R.PGM.FILE<EB.PGM.REC.VERIFY>= 'Y'    ;* set record verification to 'Y'
            WRITE R.PGM.FILE ON F.PGM.FILE,JOB.NAME         ;* write the record back and release the lock as well
        END
        R.JOB.TIMES<EB.JT.REC.VERIFY,1>='Y'
    END ELSE
        R.JOB.TIMES<EB.JT.REC.VERIFY,1>='N'
    END
* Removed the line of END.TIME variable update as it is done in required place.
    START.TIME = R.JOB.TIMES<EB.JT.START.TIME,1>  ;* Time we started
    IF END.TIME LT START.TIME THEN      ;* Must have flipped over midnight
        ELAPSED.TIME = (END.TIME + (24*3600))-START.TIME    ;* Add a day of seconds
    END ELSE
        ELAPSED.TIME = END.TIME - START.TIME      ;* How long the job took
    END

    CONTROL.LIST.COUNT =DCOUNT(R.JOB.TIMES<EB.JT.BULK.NUMBER,1>, SM)  ;* get the count of control lists
* loop through each sub value set

    FOR POS= 1 TO CONTROL.LIST.COUNT
        IF R.JOB.TIMES<EB.JT.COMPLETED,1,POS> > R.JOB.TIMES<EB.JT.PROCESSED,1,POS> THEN   ;* Could be if they've added to the list file while running
            R.JOB.TIMES<EB.JT.PROCESSED,1,POS> = R.JOB.TIMES<EB.JT.COMPLETED,1,POS>       ;* Make sure they're equal
        END ELSE
            R.JOB.TIMES<EB.JT.COMPLETED,1,POS> = R.JOB.TIMES<EB.JT.PROCESSED,1,POS>       ;* Make sure we see all completed
        END
    NEXT

    R.JOB.TIMES<EB.JT.END.TIME,1> = END.TIME
    R.JOB.TIMES<EB.JT.ELAPSED.TIME,1> = ELAPSED.TIME + SUM(R.JOB.TIMES<EB.JT.SELECT.TIME,1>)        ;* Measured in seconds and we need to include the select time

    IF ELAPSED.TIME THEN      ;* We took some time
        OVERALL.THROUGHPUT = SUM(R.JOB.TIMES<EB.JT.PROCESSED,1>) / (ELAPSED.TIME/60)      ;* Per minute
    END ELSE
        OVERALL.THROUGHPUT = SUM(R.JOB.TIMES<EB.JT.PROCESSED,1>) * 60 ;* It took no time to do everything
    END

    R.JOB.TIMES<EB.JT.THROUGHPUT,1> = INT(OVERALL.THROUGHPUT)         ;* Per minute
    R.JOB.TIMES<EB.JT.FASTEST,1> = FASTEST.THROUGHPUT       ;* Store the fastest single throughput
    AGENT.COUNT = DCOUNT(R.JOB.TIMES<EB.JT.AGENTS,1>,',')   ;* The number of agents that processed the job
    IF AGENT.COUNT = 0 THEN   ;* Very quick run - didn't get time for a progress update
        AGENT.COUNT = 1       ;* default to at least one agent
    END
    R.JOB.TIMES<EB.JT.AGENTS,1> = AGENT.COUNT     ;* Store the number of agents rather than their individual IDs

    RETURN
*-----------------------------------------------------------------------------
UPDATE.PROGESS.BATCH.STATUS:
* para to update the key count progress in BATCH.STATUS
* an enquiry could be written on batch.status to show the the no of records selected,
* currently how many processed per control.list
*
    READU R.BATCH.STATUS FROM F.BATCH.STATUS,FLAG.ID LOCKED ;* if locked by some body else
        RETURN      ;* return immediately
    END THEN
        IF CONTROL.LIST<1,1> EQ R.BATCH.STATUS<1,1> THEN    ;*We are in the current control list
            R.BATCH.STATUS<1,5> = R.BATCH.STATUS<1,5> + KEY.COUNT     ;* update the key count processed so far
        END

        WRITE R.BATCH.STATUS ON F.BATCH.STATUS,FLAG.ID      ;* write back the batch status record
    END  ELSE
        RELEASE F.BATCH.STATUS,FLAG.ID  ;* unable to read the record(strange but safe) release the lock
    END

    RETURN
*-----------------------------------------------------------------------------
*
UPDATE.TOTAL.WRITES:
* Update the lock collision count,total writes count.

    IF COLLISION.COUNT THEN   ;* lock collision
        R.JOB.TIMES<EB.JT.LOCK.COLLISION,1> += COLLISION.COUNT        ;* add up the lock collision count in the job
        COLLISION.COUNT=0     ;* reset the lock collision count
    END
    IF TOTAL.WRITES THEN      ;* writes happened
        R.JOB.TIMES<EB.JT.TOTAL.WRITE,1>+= TOTAL.WRITES     ;* add up the writes count in the job
        TOTAL.WRITES=0        ;* reset the writes count
    END

    RETURN

*-----------------------------------------------------------------------------

OPEN.LIST.FILE:
* Open the list file which goes with the job or allocate a list file from the pool
* The number of list files in the pool is = number of batch sessions. This allows
* for every session running a non-standard multi-thread job and using a list file
* from the pool. If the pool list file does not exist (ie someone has changed the
* number of sessions) then create it.
* The list file may also be a permanent activation list file.
*
    ETEXT = ''
    IF ACTIVATION.FILE THEN
        IF INDEX(PROCESS.NAME,"/",1) THEN
            F.ACTIVATION.FILE = 'F.':PROCESS.NAME[5,999]:'.LIST'
        END ELSE
            F.ACTIVATION.FILE = 'F.':PROCESS.NAME:'.LIST'
        END
        FN.LIST.NAME = F.ACTIVATION.FILE
        F.LIST.NAME = ''
        CALL OPF(FN.LIST.NAME,F.LIST.NAME)        ;* Open it
    END

    BATCH.LIST.FILE = FN.LIST.NAME      ;* In common for FATAL.ERROR - note: FNNN... full name!

    RETURN
*----------------------------------------------------------------------------
GET.LIST.FROM.POOL:
* Allocate the next free list file from the pool OR if one has already been allocated
* to this job the use it.
    READ FN.LIST.NAME FROM F.LOCKING, FLAG.ID THEN          ;* Read first, else then lock and find the free list
        CALL OCOMO("Obtained the Locking with ":FLAG.ID:" and ":FN.LIST.NAME)   ;* Output to como about the data we got
    END ELSE
        CALL EB.TRANS('START','')       ;* Start transaction boundary
        READU FN.LIST.NAME FROM F.LOCKING, FLAG.ID THEN     ;* Wait till i get the lock (Do not introduce LOCKED clause and SLEEP, as by the time i resume from sleep, the job would have completed and FLAG.ID delete and there by i will be allocating the JOB.LIST again)
            CALL OCOMO("Obtained the Locking with ":FLAG.ID:" and ":FN.LIST.NAME)         ;* Output to como about the data we got
            RELEASE F.LOCKING, FLAG.ID  ;* Release it
        END ELSE    ;* I am the first to get lock
            LIST.OWNER = 1    ;* I am allocating the .LIST file
            CALL OCOMO("Allocating List File for ":FLAG.ID)
            CALL GET.FREE.LIST.FILE(FN.LIST.NAME)
        END

        CALL OCOMO("Updating the Locking with ":FLAG.ID:" and ":FN.LIST.NAME)   ;*Output to como about the update

        WRITE FN.LIST.NAME TO F.LOCKING, FLAG.ID  ;* Allocate this file to this job and allow the other threads to pick it up
        IF LIST.OWNER EQ 1 THEN         ;*I  have allocated and locked the LIST  reference
            WRITE FLAG.ID TO F.LOCKING,FN.LIST.NAME         ;* Maintain another record in LOCKING keyed by the list file to stop other threads from picking it up
        END

        CALL EB.TRANS('END','')         ;*Commit transaction
    END
    FN.LIST.NAME<2> = 'NO.FATAL.ERROR'  ;* Still with the lock on F.LOCKING - try and open it
    CALL OPF(FN.LIST.NAME,F.LIST.NAME)  ;* Open it
    IF ETEXT THEN   ;* It's important that only one thread tries to create the list file
        GOSUB CREATE.LIST.FILE          ;* Need a new one
        CALL OPF(FN.LIST.NAME,F.LIST.NAME)        ;* Open it and fatal if we can't
    END
    BATCH.LIST.FILE = FN.LIST.NAME      ;*Set BATCH.LIST.FILE common for the fatal errors

    RETURN
*----------------------------------------------------------------------------
CREATE.LIST.FILE:
* Create the file control record (copy from list number 1) and create the list file
*
    CALL OCOMO('Creating list file ':FN.LIST.NAME)          ;* BG_100002910 S/E
    FILE.TO.CREATE = FIELD(FN.LIST.NAME,'.',2,999)
    READ R.FILE.CONTROL FROM F.FILE.CONTROL, 'JOB.LIST.1' THEN        ;* Copy number 1
        WRITE R.FILE.CONTROL TO F.FILE.CONTROL, FILE.TO.CREATE        ;* The new file
    END
    CALL EBS.CREATE.FILE(FILE.TO.CREATE,'','')    ;* And go ahead and create it

    RETURN
*----------------------------------------------------------------------------
RELEASE.LIST.FILE:
* Allow the list file to be used by another thread. Note you may not be alone in
* doing this - so allow for the records to be 'missing'

    READ R.LIST.FILE FROM F.LOCKING,FLAG.ID ELSE  ;*Read and see a valid record exists
        RETURN      ;*Someone has already done no point in doing again
    END

    READU R.LIST.FILE.NAME FROM F.LOCKING,FLAG.ID THEN      ;* If found
        IF R.LIST.FILE.NAME EQ FN.LIST.NAME THEN  ;* To check whether another instance of the job has started with a new list
            DELETE F.LOCKING, FLAG.ID   ;* Clear in case we used a file from the pool
        END ELSE
            RELEASE F.LOCKING, FLAG.ID  ;* Else just release the record
        END
    END ELSE        ;* If some other session has already deleted it
        RELEASE F.LOCKING,FLAG.ID       ;* Just release the record and get out
    END

    READU R.LIST.RECORD FROM F.LOCKING,FN.LIST.NAME THEN    ;*If found
        IF R.LIST.RECORD EQ FLAG.ID THEN          ;*Only if it is for current job
            DELETE F.LOCKING,FN.LIST.NAME         ;*Delete it and make list file available
        END ELSE
            RELEASE F.LOCKING,FN.LIST.NAME        ;*Already allocated to different job should not delete
        END
    END ELSE
        RELEASE F.LOCKING,FN.LIST.NAME  ;*Someone has cleared it already
    END


    RETURN
*-----------------------------------------------------------------------------
DISTRIBUTE.LIST.RECORDS:

*In case we are in the last few records, and if the list file contains more than one batch key to process
*split up the list keys. The new key to the list file will be the existing key suffixed with N where N is the nth
*batch key in the existing list record. After forming the new keys the old record will be deleted

    CALL EB.TRANS('START',RMSG)         ;*Start the Transaction
    NO.OF.LIST.KEYS = DCOUNT(LIST.RECORD,FM)      ;*Total ids in this list record
    FOR LIDX = 1 TO NO.OF.LIST.KEYS     ;*Loop through one by one
        WRITE LIST.RECORD<LIDX> ON F.LIST.NAME,LIST.KEY:"-":LIDX      ;*Write it with the LIST.KEY-Counter
    NEXT LIDX
    DELETE F.LIST.NAME,LIST.KEY         ;*Delete the original
    CALL EB.TRANS('END',RMSG) ;*Commit the Transacction

    RETURN

*************************************************************************
DW.PROCESSING:

* Data Warehousing. Extraction from OLTP database. On every record commit
* we pass on the details on the files updated to check whether we are
* interested in the file update.
*
    IF DW$INSTALLED THEN      ;* if DW module is installed
        IF SET.COLLECT = 0 THEN
            ASSIGN DW$EXTRACT.MODE TO SYSTEM(1039)
            SET.COLLECT = 1
        END ELSE
            DW.FILE.DETAILS = SYSTEM(1039)        ;* details of all the files updated
            WRK.FILE.ID = FLAG.ID       ;* id for the wrk and activation file
            CALL EB.TRANS('START',RETURN.MSG)     ;* Start a transaction
            CALL DW.PROCESS.TXN(WRK.FILE.ID,DW.FILE.DETAILS,RETURN.VAR)         ;* extract
            CALL EB.TRANS('END',RETURN.MSG)       ;* End transaction
            SEL.COLLECT = 0
        END
    END

    RETURN
*-----------------------------------------------------------------------------

*
CHK.STILL.HOLD.LIST.FILE:

    IF NOT(FN.LIST.NAME) THEN ;*Nothing has been allocated yet
        RETURN      ;*No need to do the check
    END

    READ THE.LIST.FILE FROM F.LOCKING,FLAG.ID ELSE          ;* get the name of the list file allocated
        THE.LIST.FILE = ''    ;* cannot read, strange but possible
    END

    IF THE.LIST.FILE NE FN.LIST.NAME THEN         ;* if the allocated and the current one are not the same
        RELEASE F.BATCH.STATUS, FLAG.ID ;* Because we locked it at the top of the loop
        CALL OCOMO("List File ":FN.LIST.NAME:" not associated  to this Job Anymore")
        GOTO PROGRAM.ABORT    ;* Back to S.JOB.RUN immediately
    END
    RETURN
*---------------------------------------------------------------------------------

PROGRAM.ABORT:
    RETURN TO PROGRAM.ABORT
*----------------------------------------------------------------------------------

PROGRAM.END:

    CALL TSA.STATUS.UPDATE('STOPPED')   ;* mark the AGENT as STOPPED
    CRT "Agent stopped"
    EXECUTE 'COMO OFF'        ;* Switch off the COMO when service is stopped

* Only for eld UniVerse releases
    STOP  ;* Cannot continue - do not go back to S.JOB.RUN (otherwise it will think the job has completed successfully)

*-----------------------------------------------------------------------------
*

UPDATE.PROGRESS.BATCH.STATUS:
*
* para to update the key count progress in BATCH.STATUS
* an enquiry could be written on batch.status to show the the no of records selected,
* currently how many processed per control.list
*
    READU R.BATCH.STATUS FROM F.BATCH.STATUS,FLAG.ID LOCKED ;* if locked by some body else
        RETURN      ;* return immediately
    END THEN
        IF CONTROL.LIST<1,1> EQ R.BATCH.STATUS<1,1> THEN    ;*We are in the current control list
            R.BATCH.STATUS<1,5> = R.BATCH.STATUS<1,5> + KEY.COUNT     ;* update the key count processed so far
        END

        WRITE R.BATCH.STATUS ON F.BATCH.STATUS,FLAG.ID      ;* write back the batch status record
    END  ELSE
        RELEASE F.BATCH.STATUS,FLAG.ID  ;* unable to read the record(strange but safe) release the lock
    END


    RETURN

*-----------------------------------------------------------------------------
*
CHECK.TXN.MGMT:
*
    IF TXN.MGMT THEN          ;* Check if the job is run with the transaction management
        R.JOB.TIMES<EB.JT.TXN.MANAGEMENT,1>= 'Y'  ;* update the field as 'Y'
    END ELSE
        R.JOB.TIMES<EB.JT.TXN.MANAGEMENT,1>=  'N' ;* update the field as 'N'
    END

    RETURN

*-----------------------------------------------------------------------------
*
CHECK.RECORD.VERIFICATION:
*
*See whether the record routine has the verification mechanism .
* For a multithreaded job,if the record routine has got the mechanism to eliminate unnecessary keys,
* then it returns -1(processing) or -2(eliminating).If it does then set the variable
* RECORD.VERIFICATION to 'Y' so that REC.VER field in the PGM.FILE of the JOB is set to 'Y'.

    IF NOT(RECORD.VERIFICATION) AND KEY.TO.PASS<1> MATCHES '-1':VM:'-2' THEN    ;* if -1 or -2 is passed from the record routine and RECORD.VERIFICATION has not been set yet
        RECORD.VERIFICATION='Y'
    END
    RETURN

*-----------------------------------------------------------------------------
*
CHECK.CACHE:
* checks whether the record routine has actually used the cache and write cache updates
*
    IF NOT(ROUTINE.USED.CACHE) AND NOT(CACHE.OFF) THEN      ;* the record routine has used the cache.(CACHE.OFF=0)
        ROUTINE.USED.CACHE='Y'
    END

* If the WRITE.CACHE is set , then flush the data from the
* cache variables and write it into the disk as we do it in JOURNAL.UPDATE

    IF WRITE.CACHE THEN       ;*  WRITE.CACHE set
        GOSUB WRITE.INTO.DISK ;* write into the disk
    END

    RETURN

*-----------------------------------------------------------------------------
*
WRITE.INTO.DISK:
*
* loop through the cache varables and write the records into the disk
    CACHE.COUNT = DCOUNT(FWT,@FM)       ;* Number of records in the cache

    FOR CIDX = 1 TO CACHE.COUNT         ;* For every record in the cache
        IF FWF(CIDX)[1,1]='W' THEN      ;* Should I write it
            FILE.DETAILS = FWT<CIDX>    ;* Name and ID from cache
            FL = FILE.DETAILS[" ",1,1]  ;* File name
            ID = FILE.DETAILS[" ",2,1]  ;* ID
            RC = FWC(CIDX)    ;* Record to write
            CALL OPF(FL,F.FL) ;* Get file variable
            IF RC NE 'DELETE' THEN      ;* If the record is not deleted
                WRITE RC TO F.FL, ID ON ERROR
                    TEXT = 'Cannot write ':ID:' to ':FL     ;* Write error
                    CALL FATAL.ERROR('BATCH.JOB.CONTROL')
                END
            END
        END
    NEXT CIDX

    RETURN

*-----------------------------------------------------------------------------
*
CLEAR.SELECTION.VARIABLES:
*
* clear the selection and bulking common varables so that it is set correctly for the
* next CONTROL.LIST selection or next job selection

    BULK.NUMBER=0   ;* initilaise the records bulked common variable
    SELECTION.MODE=''         ;* initialise the selection mode variable
    SELECT.STATEMENT=''       ;* initialise the select statement variable

    RETURN

*-----------------------------------------------------------------------------
*
SET.CACHE.VARIABLES:
* sets and resets the cache variables

*
* If the job doesn't want to use the cache,set CACHE.OFF=1 and WRITE.CACHE=0 so that a F.WRITE
* and F.MATWRITE would actually write into the disk
* By default, the job would use the cache. set CACHE.OFF= 0 and WRITE.CACHE =1 so that a F.WRITE
* and F.MATWRITE would actually write into the cache and flushed latter.

    BEGIN CASE
    CASE SET.CACHE  ;* set the cache variables
        IF USE.CACHE THEN     ;*  use the cache
            CACHE.OFF=0       ;* turn the cache on
            WRITE.CACHE=1     ;* set the write cache so that F.WRITE and F.MATWRITE would actually write into the cache
        END ELSE
            CACHE.OFF=1       ;* turn the cache off
            WRITE.CACHE =0    ;* turn off the write cache
        END
    CASE OTHERWISE  ;* reset the cache variables
        CACHE.OFF=1 ;* make sure that the cache is turned off
        WRITE.CACHE=0         ;* write cache is turned off as well

    END CASE
    RETURN

*------------------------------------------------------------------------------

*** <region name= UPDATE.TEC.JOB.SELECT>
UPDATE.TEC.JOB.SELECT:
*** <desc>Update Temenos Enterprise Console with JOB.SELECT event </desc>

    ITEM.ID = "JOB.SELECT"
    GOSUB BUILD.MY.KEY
    MY.DETAIL = ""
    MY.VALUE = KEYS.PROCESSED
    CALL TEC.RECORD.ACTIVITY(ITEM.ID, MY.KEY, MY.DETAIL, MY.VALUE)

    RETURN

*** </region>

*-----------------------------------------------------------------------------

*** <region name= UPDATE.TEC.JOB.PROGRESS>
UPDATE.TEC.JOB.PROGRESS:
*** <desc>Update Temenos Enterprise Console with JOB.PROGRESS event </desc>

    ITEM.ID = "JOB.PROGRESS"
    GOSUB BUILD.MY.KEY
    MY.DETAIL = ""
    MY.VALUE = KEYS.PROCESSED
    CALL TEC.RECORD.ACTIVITY(ITEM.ID, MY.KEY, MY.DETAIL, MY.VALUE)

    RETURN

*** </region>

*-----------------------------------------------------------------------------

*** <region name= BUILD.MY.KEY>
BUILD.MY.KEY:
*** <desc>Build MY.KEY </desc>

    MY.KEY = ID.COMPANY : "_" : C$BATCH.START.DATE : "-"
    MY.KEY := PROCESS.NAME : "_" : JOB.INFO["_", 1, 1] : "_" : JOB.INFO["_", 4, 1]

    RETURN

*** </region>

END
